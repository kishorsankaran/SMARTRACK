<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMARTTRACK</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom styles can be added here or in a separate file if preferred, but Tailwind is primary */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font as per existing page */
            background-color: #f3f4f6; /* Light gray background */
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #1f2937; /* Darker gray for header */
            color: #fff;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e5e7eb;
        }
        .tab-button {
            padding: 10px 15px;
            border: none;
            background-color: #e5e7eb;
            cursor: pointer;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            margin-right: 5px;
            transition: all 0.3s ease;
            font-weight: 500;
            color: #4b5563;
        }
        .tab-button:hover {
            background-color: #d1d5db;
        }
        .tab-button.active {
            background-color: #fff;
            border-bottom: 2px solid #3b82f6; /* Blue indicator for active tab */
            color: #1f2937;
            font-weight: 600;
        }
        .page-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .form-section {
            margin-bottom: 20px;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background-color: #f9fafb;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #374151;
        }
        .form-group input[type="text"],
        .form-group input[type="email"],
        .form-group input[type="password"],
        .form-group input[type="date"],
        .form-group input[type="time"],
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            box-sizing: border-box;
            transition: border-color 0.2s ease-in-out;
            background-color: #fff;
        }
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
        }
        .action-button {
            background-color: #3b82f6; /* Blue */
            color: #fff;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .action-button:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .action-button:active {
            transform: translateY(0);
        }
        .secondary-button {
            background-color: #6b7280; /* Gray */
            color: #fff;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-left: 10px; /* Space between buttons */
        }
        .secondary-button:hover {
            background-color: #4b5563;
            transform: translateY(-1px);
        }
        .secondary-button:active {
            transform: translateY(0);
        }
        .danger-button {
            background-color: #ef4444; /* Red */
            color: #fff;
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .danger-button:hover {
            background-color: #dc2626;
            transform: translateY(-1px);
        }
        .edit-button {
            background-color: #10b981; /* Green */
            color: #fff;
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .edit-button:hover {
            background-color: #059669;
            transform: translateY(-1px);
        }
        .table-container {
            overflow-x: auto; /* Enable horizontal scrolling for tables */
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #fff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 12px 15px;
            text-align: left;
            white-space: nowrap; /* Prevent text wrapping in table cells */
        }
        th {
            background-color: #f3f4f6;
            font-weight: 600;
            color: #4b5563;
            text-transform: uppercase;
            font-size: 14px;
        }
        tr:nth-child(even) {
            background-color: #f9fafb;
        }
        tr:hover {
            background-color: #f0f4f8;
        }
        .action-buttons button {
            margin-right: 5px;
        }
        .hidden {
            display: none !important;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .modal-content h3 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #1f2937;
        }
        .modal-content p {
            font-size: 16px;
            color: #4b5563;
            margin-bottom: 25px;
        }
        .modal-buttons button {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin: 0 10px;
            transition: background-color 0.3s ease;
        }
        .modal-buttons .confirm-yes {
            background-color: #3b82f6;
            color: #fff;
            border: none;
        }
        .modal-buttons .confirm-yes:hover {
            background-color: #2563eb;
        }
        .modal-buttons .confirm-no {
            background-color: #e5e7eb;
            color: #4b5563;
            border: 1px solid #d1d5db;
        }
        .modal-buttons .confirm-no:hover {
            background-color: #d1d5db;
        }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher than modals */
            color: white;
            font-size: 1.5rem;
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Auth Container Specific Styles */
        /* Changed to flex for two columns on medium+ screens */
        #authContainer {
            display: flex;
            flex-direction: column; /* Default to column for mobile */
            min-height: 100vh;
            background-color: #f3f4f6;
            width: 100%; /* Ensure it takes full width */
            align-items: stretch; /* Stretch children to fill height */
        }

        @media (min-width: 768px) { /* Medium screens and up */
            #authContainer {
                flex-direction: row; /* Two columns */
            }
            .auth-left-pane {
                display: flex !important; /* Ensure it's shown as flex */
                width: 50%; /* Half width */
            }
            .auth-right-pane {
                width: 50%; /* Half width */
            }
        }

        .auth-left-pane {
            /* Hide by default on mobile, show on medium+ */
            display: none;
            background-color: #1f2937; /* Dark background color */
            color: #fff;
            display: flex;
            align-items: flex-start; /* Aligned to the top */
            justify-content: center;
            padding: 2rem;
            padding-top: 8rem; /* Pushes content up */
            text-align: center;
        }
        .auth-left-pane h1 {
            font-size: 3.5rem; /* Large font for SMARTTRACK */
            font-weight: 800; /* Extra bold */
            letter-spacing: 0.1em; /* Slight letter spacing */
        }

        .auth-right-pane {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem; /* Smaller padding for mobile */
            flex-grow: 1; /* Allow it to grow on mobile */
        }
        @media (min-width: 768px) {
            .auth-right-pane {
                padding: 2rem; /* Larger padding on desktop */
            }
        }

        .auth-card {
            background-color: #fff;
            padding: 20px; /* Reduced padding */
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            width: 100%; /* Take full width of its pane */
            max-width: 320px; /* Smaller max-width for the card itself */
            text-align: center;
        }
        .auth-card h2 {
            font-size: 24px; /* Slightly reduced font size for h2 */
            font-weight: 700;
            margin-bottom: 20px; /* Reduced margin */
            color: #1f2937;
        }
        .auth-card .form-group {
            margin-bottom: 15px; /* Reduced margin */
            text-align: left;
        }
        .auth-card input[type="email"],
        .auth-card input[type="password"] {
            padding: 8px 12px; /* Smaller padding for inputs */
        }
        .auth-card button {
            width: 100%;
            margin-top: 15px; /* Reduced margin */
            padding: 8px 15px; /* Smaller padding for buttons */
        }
        .auth-card .toggle-mode-link {
            margin-top: 15px; /* Reduced margin */
            font-size: 0.875rem; /* Smaller font size */
            color: #6b7280;
        }
        .status-indicators {
            margin-top: 15px; /* Reduced margin */
            font-size: 0.8rem; /* Smaller font size */
            color: #555;
            text-align: left;
            padding: 10px; /* Smaller padding */
            /* Hide by default as requested */
            display: none;
        }
        .status-indicators span {
            display: block;
            margin-bottom: 3px; /* Reduced margin */
        }
        .status-indicators .ok {
            color: #10b981; /* Green */
        }
        .status-indicators .error {
            color: #ef4444; /* Red */
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="hidden">
        <div class="flex flex-col items-center">
            <div class="spinner"></div>
            <span id="loadingMessage">Loading...</span>
        </div>
    </div>

    <!-- Custom Message Modal -->
    <div id="messageModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="messageModalTitle"></h3>
            <p id="messageModalMessage"></p>
            <div class="modal-buttons">
                <button class="action-button" onclick="hideMessageModal()">OK</button>
            </div>
        </div>
    </div>

    <!-- Custom Confirm Modal -->
    <div id="customConfirmModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="customConfirmTitle">Confirm Action</h3>
            <p id="customConfirmMessage"></p>
            <div class="modal-buttons">
                <button class="confirm-yes action-button" onclick="handleCustomConfirm(true)">Yes</button>
                <button class="confirm-no secondary-button" onclick="handleCustomConfirm(false)">No</button>
            </div>
        </div>
    </div>

    <!-- Forgot Password Modal -->
    <div id="forgotPasswordModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-2xl font-semibold mb-4 text-gray-700">Reset Password</h3>
            <p class="text-gray-600 mb-6">Enter your email address to receive a password reset link.</p>
            <div class="form-group">
                <label for="resetEmail" class="sr-only">Email</label>
                <input type="email" id="resetEmail" placeholder="your.email@example.com" class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="flex justify-end space-x-4 mt-6">
                <button type="button" class="action-button" onclick="sendPasswordReset()">Send Reset Email</button>
                <button type="button" class="secondary-button" onclick="hideForgotPasswordModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Authentication Container -->
    <div id="authContainer">
        <!-- Left Pane for SMARTTRACK Logo/Name -->
        <div class="auth-left-pane">
            <h1>SMARTTRACK</h1>
        </div>

        <!-- Right Pane for Authentication Card -->
        <div class="auth-right-pane">
            <div class="auth-card">
                <h2 id="authTitle">Sign In</h2>
                <div class="form-group">
                    <label for="authEmail">Email:</label>
                    <input type="email" id="authEmail" placeholder="your.email@example.com">
                </div>
                <div class="form-group">
                    <label for="authPassword">Password:</label>
                    <input type="password" id="authPassword" placeholder="••••••••">
                </div>
                <button id="authSubmitButton" class="action-button" onclick="handleAuthSubmit()">Sign In</button>
                <p class="toggle-mode-link">
                    Don't have an account? <button onclick="toggleAuthMode()" class="text-blue-600 hover:underline">Sign Up</button>
                </p>
                <p class="mt-4 text-sm">
                    <button onclick="showForgotPasswordModal()" class="text-blue-600 hover:underline">Forgot Password?</button>
                </p>
                <button class="secondary-button mt-4" onclick="signInAnonymouslyUser()">Continue Anonymously</button>

                <!-- Application Status: Hidden by default to reduce form height -->
                <!-- To show, remove `display: none;` from `.status-indicators` in style block -->
                <div class="status-indicators">
                    <p>Application Status:</p>
                    <span>User ID: <span id="displayUserId">N/A</span></span>
                    <span>App ID: <span id="appIdStatus">N/A</span></span>
                    <span>Firebase Config: <span id="firebaseConfigStatus">N/A</span></span>
                    <p class="text-sm text-gray-500 mt-2">For persistent data, please ensure Firebase is correctly configured and authenticated.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Application Container -->
    <div id="appContainer" class="container hidden">
        <header class="header">
            <h1 class="text-3xl font-bold">Document Control Register</h1>
            <div class="flex items-center">
                <span id="displayUserId" class="text-sm font-medium mr-4"></span>
                <button onclick="handleSignOut()" class="secondary-button">Sign Out</button>
            </div>
        </header>

        <nav class="tab-buttons">
            <button class="tab-button active" onclick="showPage('inspectionsPage')">Inspections Register</button>
            <button class="tab-button" onclick="showPage('mirPage')">MIR Register</button>
            <button class="tab-button" onclick="showPage('ncrPage')">NCR Register</button>
            <button class="tab-button" onclick="showPage('submissionPage')">Submission Register</button>
            <button class="tab-button" onclick="showPage('correspondencePage')">Correspondence Register</button>
        </nav>

        <!-- Inspections Register Page -->
        <div id="inspectionsPage" class="page-content">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Inspections Register</h2>

            <!-- Form for Inspections -->
            <div class="form-section">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">Add/Edit Inspection</h3>
                <form id="inspectionForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <div class="form-group">
                        <label for="date">Date:</label>
                        <input type="date" id="date" required>
                    </div>
                    <div class="form-group">
                        <label for="discipline">Discipline:</label>
                        <select id="discipline" required>
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from disciplinePrefixMap -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="insNumber">INS Number:</label>
                        <input type="text" id="insNumber" placeholder="e.g., CP837-INS-CIV-0001" required>
                        <span class="text-xs text-gray-500 mt-1">Next: <span id="nextInsNumber">Loading...</span></span>
                    </div>
                    <div class="form-group">
                        <label for="revision">Revision:</label>
                        <input type="text" id="revision" placeholder="e.g., 0, 1, A" required>
                    </div>
                    <div class="form-group">
                        <label for="location">Location:</label>
                        <input type="text" id="location" placeholder="e.g., Area 1">
                    </div>
                    <!-- Removed Submission Type from form -->
                    <div class="form-group">
                        <label for="workToBeInspected">Work To Be Inspected:</label>
                        <textarea id="workToBeInspected" rows="2" placeholder="Description of work"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="inspectionDate">Inspection Date:</label>
                        <input type="date" id="inspectionDate">
                    </div>
                    <div class="form-group">
                        <label for="inspectionTime">Inspection Time:</label>
                        <input type="time" id="inspectionTime">
                    </div>
                    <div class="form-group">
                        <label for="approvedDrawingRef">Approved Drawing Ref.:</label>
                        <input type="text" id="approvedDrawingRef" placeholder="e.g., DWG-001">
                    </div>
                    <div class="form-group">
                        <label for="specificationRef">Specification Ref.:</label>
                        <input type="text" id="specificationRef" placeholder="e.g., SPE-001">
                    </div>
                    <div class="form-group">
                        <label for="approvedMethodStatementRef">Approved Method Statement Ref.:</label>
                        <input type="text" id="approvedMethodStatementRef" placeholder="e.g., MST-001">
                    </div>
                    <div class="form-group">
                        <label for="qcsReference">QCS Reference:</label>
                        <input type="text" id="qcsReference" placeholder="e.g., QCS-2014">
                    </div>
                    <div class="form-group">
                        <label for="commentReceivedDate">Comment Received Date:</label>
                        <input type="date" id="commentReceivedDate">
                    </div>
                    <div class="form-group">
                        <label for="documentStatus">Document Status:</label>
                        <select id="documentStatus" required>
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from inspectionStatusOptions -->
                        </select>
                    </div>
                     <div class="form-group">
                        <label for="revStatus">Lifecycle Status:</label>
                        <input type="text" id="revStatus" readonly class="bg-gray-100 text-gray-500">
                    </div>
                    <div class="form-group col-span-full flex justify-end space-x-2">
                        <button type="button" id="addUpdateButton" class="action-button" onclick="addUpdateInspectionDocument()">Add Document</button>
                        <button type="button" class="secondary-button" onclick="clearInspectionsForm()">Clear Form</button>
                    </div>
                </form>
            </div>

            <!-- Inspections Table -->
            <div class="table-section mt-8">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold text-gray-700">All Inspections</h3>
                    <div class="flex space-x-2">
                        <button class="secondary-button" id="toggleInspectionsTableBtn" onclick="toggleTableVisibility('inspectionsTableContainer', 'toggleInspectionsTableBtn')">Hide Table</button>
                        <button class="action-button" onclick="downloadInspectionsCSV()">Download CSV</button>
                    </div>
                </div>

                <!-- Search and Filter -->
                <div class="flex flex-wrap items-end gap-4 mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <div class="form-group m-0 flex-grow">
                        <label for="inspectionsSearchField" class="text-sm">Search Field:</label>
                        <select id="inspectionsSearchField" class="w-full">
                            <option value="">All Fields</option>
                            <option value="date">Date</option>
                            <option value="discipline">Discipline</option>
                            <option value="insNumber">INS Number</option>
                            <option value="revision">Revision</option>
                            <option value="location">Location</option>
                            <!-- Removed Submission Type from search filter -->
                            <option value="workToBeInspected">Work To Be Inspected</option>
                            <option value="inspectionDate">Inspection Date</option>
                            <option value="inspectionTime">Inspection Time</option>
                            <option value="approvedDrawingRef">Approved Drawing Ref.</option>
                            <option value="specificationRef">Specification Ref.</option>
                            <option value="approvedMethodStatementRef">Approved Method Statement Ref.</option>
                            <option value="qcsReference">QCS Reference</option>
                            <option value="commentReceivedDate">Comment Received Date</option>
                            <option value="documentStatus">Document Status</option>
                            <option value="revStatus">Lifecycle Status</option>
                            <option value="approvalSummaryStatus">Approval Summary</option>
                        </select>
                    </div>
                    <div class="form-group m-0 flex-grow-[2]">
                        <label for="inspectionsSearchTerm" class="text-sm">Search Term:</label>
                        <input type="text" id="inspectionsSearchTerm" placeholder="Enter search term" class="w-full">
                    </div>
                    <div class="flex space-x-2">
                        <button class="action-button" onclick="performInspectionsSearch()"><i class="fas fa-search"></i> Search</button>
                        <button class="secondary-button" onclick="clearInspectionsSearch()"><i class="fas fa-redo"></i> Reset</button>
                    </div>
                </div>

                <div id="inspectionsTableContainer" class="table-container">
                    <table id="inspectionsTable">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Discipline</th>
                                <th>INS No.</th>
                                <th>Rev.</th>
                                <th>Location</th>
                                <!-- Removed Sub. Type from table header -->
                                <th>Work to be Inspected</th>
                                <th>Insp. Date</th>
                                <th>Insp. Time</th>
                                <th>Appr. Drawing Ref.</th>
                                <th>Spec. Ref.</th>
                                <th>Appr. MS Ref.</th>
                                <th>QCS Ref.</th>
                                <th>Comment Rec. Date</th>
                                <th>Doc. Status</th>
                                <th>Lifecycle Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Inspection rows will be rendered here by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- MIR Register Page -->
        <div id="mirPage" class="page-content hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Material Inspection Request (MIR) Register</h2>

            <!-- Form for MIR -->
            <div class="form-section">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">Add/Edit MIR</h3>
                <form id="mirForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <div class="form-group">
                        <label for="mirDate">MIR Date:</label>
                        <input type="date" id="mirDate" required>
                    </div>
                    <div class="form-group">
                        <label for="mirDiscipline">Discipline:</label>
                        <select id="mirDiscipline" required>
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from disciplinePrefixMap -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="mirNumber">MIR Number:</label>
                        <input type="text" id="mirNumber" placeholder="e.g., CP837-MIR-CIV-0001" required>
                        <span class="text-xs text-gray-500 mt-1">Next: <span id="nextMirNumber">Loading...</span></span>
                    </div>
                    <div class="form-group">
                        <label for="mirRevision">Revision:</label>
                        <input type="text" id="mirRevision" placeholder="e.g., 0, 1, A" required>
                    </div>
                    <div class="form-group">
                        <label for="dateMaterialReceived">Date Material Received:</label>
                        <input type="date" id="dateMaterialReceived">
                    </div>
                    <div class="form-group">
                        <label for="mirInspectionDate">MIR Inspection Date:</label>
                        <input type="date" id="mirInspectionDate">
                    </div>
                    <div class="form-group">
                        <label for="mirInspectionTime">MIR Inspection Time:</label>
                        <input type="time" id="mirInspectionTime">
                    </div>
                    <div class="form-group">
                        <label for="materialApprovalRef">Material Approval Ref.:</label>
                        <input type="text" id="materialApprovalRef" placeholder="e.g., MAT-APP-001">
                    </div>
                    <div class="form-group">
                        <label for="descriptionMaterial">Description of Material:</label>
                        <textarea id="descriptionMaterial" rows="2" placeholder="Description"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="deliveryNoteNumber">Delivery Note Number:</label>
                        <input type="text" id="deliveryNoteNumber" placeholder="e.g., DN-12345">
                    </div>
                    <div class="form-group">
                        <label for="manufacturer">Manufacturer:</label>
                        <input type="text" id="manufacturer" placeholder="e.g., Company A">
                    </div>
                    <div class="form-group">
                        <label for="supplier">Supplier:</label>
                        <input type="text" id="supplier" placeholder="e.g., Supplier X">
                    </div>
                    <div class="form-group">
                        <label for="countryOrigin">Country of Origin:</label>
                        <input type="text" id="countryOrigin" placeholder="e.g., China">
                    </div>
                    <div class="form-group">
                        <label for="mirSubmissionDate">MIR Submission Date:</label>
                        <input type="date" id="mirSubmissionDate">
                    </div>
                    <div class="form-group">
                        <label for="mirResponseDate">MIR Response Date:</label>
                        <input type="date" id="mirResponseDate">
                    </div>
                    <div class="form-group">
                        <label for="mirApprovalStatus">Approval Status:</label>
                        <select id="mirApprovalStatus" required>
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from mirApprovalStatusOptions -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="mirRevStatus">Lifecycle Status:</label>
                        <input type="text" id="mirRevStatus" readonly class="bg-gray-100 text-gray-500">
                    </div>
                    <div class="form-group col-span-full flex justify-end space-x-2">
                        <button type="button" id="addUpdateMirButton" class="action-button" onclick="addUpdateMirDocument()">Add Document</button>
                        <button type="button" class="secondary-button" onclick="clearMirForm()">Clear Form</button>
                    </div>
                </form>
            </div>

            <!-- MIR Table -->
            <div class="table-section mt-8">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold text-gray-700">All MIRs</h3>
                    <div class="flex space-x-2">
                        <button class="secondary-button" id="toggleMirTableBtn" onclick="toggleTableVisibility('mirTableContainer', 'toggleMirTableBtn')">Hide Table</button>
                        <button class="action-button" onclick="downloadMirCSV()">Download CSV</button>
                    </div>
                </div>

                <!-- Search and Filter -->
                <div class="flex flex-wrap items-end gap-4 mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <div class="form-group m-0 flex-grow">
                        <label for="mirSearchField" class="text-sm">Search Field:</label>
                        <select id="mirSearchField" class="w-full">
                            <option value="">All Fields</option>
                            <option value="mirDate">MIR Date</option>
                            <option value="mirDiscipline">Discipline</option>
                            <option value="mirNumber">MIR Number</option>
                            <option value="mirRevision">Revision</option>
                            <option value="dateMaterialReceived">Date Material Received</option>
                            <option value="mirInspectionDate">MIR Inspection Date</option>
                            <option value="mirInspectionTime">MIR Inspection Time</option>
                            <option value="materialApprovalRef">Material Approval Ref.</option>
                            <option value="descriptionMaterial">Description of Material</option>
                            <option value="deliveryNoteNumber">Delivery Note Number</option>
                            <option value="manufacturer">Manufacturer</option>
                            <option value="supplier">Supplier</option>
                            <option value="countryOrigin">Country of Origin</option>
                            <option value="mirSubmissionDate">MIR Submission Date</option>
                            <option value="mirResponseDate">MIR Response Date</option>
                            <option value="mirApprovalStatus">Approval Status</option>
                            <option value="mirRevStatus">Lifecycle Status</option>
                            <option value="mirApprovalSummaryStatus">Approval Summary</option>
                        </select>
                    </div>
                    <div class="form-group m-0 flex-grow-[2]">
                        <label for="mirSearchTerm" class="text-sm">Search Term:</label>
                        <input type="text" id="mirSearchTerm" placeholder="Enter search term" class="w-full">
                    </div>
                    <div class="flex space-x-2">
                        <button class="action-button" onclick="performMirSearch()"><i class="fas fa-search"></i> Search</button>
                        <button class="secondary-button" onclick="clearMirSearch()"><i class="fas fa-redo"></i> Reset</button>
                    </div>
                </div>

                <div id="mirTableContainer" class="table-container">
                    <table id="mirTable">
                        <thead>
                            <tr>
                                <th>MIR Date</th>
                                <th>Discipline</th>
                                <th>MIR No.</th>
                                <th>Rev.</th>
                                <th>Date Mat. Rec.</th>
                                <th>MIR Insp. Date</th>
                                <th>MIR Insp. Time</th>
                                <th>Mat. Appr. Ref.</th>
                                <th>Description of Material</th>
                                <th>Delivery Note No.</th>
                                <th>Manufacturer</th>
                                <th>Supplier</th>
                                <th>Country of Origin</th>
                                <th>MIR Sub. Date</th>
                                <th>MIR Resp. Date</th>
                                <th>Appr. Status</th>
                                <th>Lifecycle Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- MIR rows will be rendered here by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- NCR Register Page -->
        <div id="ncrPage" class="page-content hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Non-Conformance Report (NCR) Register</h2>

            <!-- Form for NCR -->
            <div class="form-section">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">Add/Edit NCR</h3>
                <form id="ncrForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Part A -->
                    <h4 class="col-span-full text-lg font-semibold text-blue-700 mt-2 mb-2">Part A: Non-Conformance Details</h4>
                    <div class="form-group">
                        <label for="ncrDiscipline">Discipline:</label>
                        <select id="ncrDiscipline" required onchange="autoFillNcrDetails()">
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from disciplinePrefixMap -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="ncrRefNumber">NCR Ref. Number:</label>
                        <input type="text" id="ncrRefNumber" placeholder="e.g., CP837-NCR-CIV-0001" required onchange="autoFillNcrDetails()">
                    </div>
                    <div class="form-group">
                        <label for="ncrDescription">NCR Description:</label>
                        <textarea id="ncrDescription" rows="2" placeholder="Describe the non-conformance"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="partAReceivedDate">Part A Received Date:</label>
                        <input type="date" id="partAReceivedDate">
                    </div>

                    <!-- Part B -->
                    <h4 class="col-span-full text-lg font-semibold text-blue-700 mt-4 mb-2">Part B: Root Cause & Corrective Action</h4>
                    <div class="form-group">
                        <label for="ncrRev_PartB">Part B Revision:</label>
                        <input type="text" id="ncrRev_PartB" placeholder="e.g., 0, 1, A" required readonly class="bg-gray-100 text-gray-500">
                    </div>
                    <div class="form-group">
                        <label for="ncrRevisedParts_PartB">Revised Parts (Part B):</label>
                        <input type="text" id="ncrRevisedParts_PartB" placeholder="e.g., Part A & B">
                    </div>
                    <div class="form-group">
                        <label for="immediateAction">Immediate Action:</label>
                        <textarea id="immediateAction" rows="2" placeholder="Action taken immediately"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="rootCause">Root Cause:</label>
                        <textarea id="rootCause" rows="2" placeholder="Identify the root cause"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="correctiveAction">Corrective Action:</label>
                        <textarea id="correctiveAction" rows="2" placeholder="Plan for corrective action"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="partBSubmittedDate">Part B Submitted Date:</label>
                        <input type="date" id="partBSubmittedDate">
                    </div>

                    <!-- Part C -->
                    <h4 class="col-span-full text-lg font-semibold text-blue-700 mt-4 mb-2">Part C: GEC Review</h4>
                    <div class="form-group">
                        <label for="partCReceivedDate">Part C Received Date:</label>
                        <input type="date" id="partCReceivedDate">
                    </div>
                    <div class="form-group">
                        <label for="partBAcceptedByGEC">Part B Accepted by GEC?:</label>
                        <select id="partBAcceptedByGEC">
                            <option value="">--Select--</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="ifPartBAccepted">If Part B Accepted:</label>
                        <input type="text" id="ifPartBAccepted" readonly class="bg-gray-100 text-gray-500">
                    </div>

                    <!-- Part D -->
                    <h4 class="col-span-full text-lg font-semibold text-blue-700 mt-4 mb-2">Part D: Proposed Corrective Action Implementation</h4>
                    <div class="form-group">
                        <label for="partDRev">Part D Revision:</label>
                        <input type="text" id="partDRev" placeholder="e.g., 0, 1, A">
                    </div>
                    <div class="form-group">
                        <label for="partDRevisedParts">Revised Parts (Part D):</label>
                        <input type="text" id="partDRevisedParts" placeholder="e.g., Part A, B & D">
                    </div>
                    <div class="form-group">
                        <label for="partDSubmittedDate">Part D Submitted Date:</label>
                        <input type="date" id="partDSubmittedDate">
                    </div>

                    <!-- Part E -->
                    <h4 class="col-span-full text-lg font-semibold text-blue-700 mt-4 mb-2">Part E: Verification of Corrective Action Effectiveness</h4>
                    <div class="form-group">
                        <label for="partEReceivedDate">Part E Received Date:</label>
                        <input type="date" id="partEReceivedDate">
                    </div>
                    <div class="form-group">
                        <label for="partEStatus">Part E Status:</label>
                        <input type="text" id="partEStatus" placeholder="e.g., Closed, Verified">
                    </div>
                    <div class="form-group">
                        <label for="ncrCurrentStatus">NCR Current Status:</label>
                        <select id="ncrCurrentStatus">
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from ncrStatuses -->
                        </select>
                    </div>

                    <div class="form-group col-span-full flex justify-end space-x-2">
                        <button type="button" id="addUpdateNcrButton" class="action-button" onclick="handleNcrFormSubmission()">Add Document</button>
                        <button type="button" class="secondary-button" onclick="clearNcrForm()">Clear Form</button>
                    </div>
                </form>
            </div>

            <!-- NCR Table -->
            <div class="table-section mt-8">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold text-gray-700">All NCRs</h3>
                    <div class="flex space-x-2">
                        <button class="secondary-button" id="toggleNcrTableBtn" onclick="toggleTableVisibility('ncrTableContainer', 'toggleNcrTableBtn')">Hide Table</button>
                        <button class="action-button" onclick="downloadNcrCSV()">Download CSV</button>
                    </div>
                </div>

                <!-- Search and Filter -->
                <div class="flex flex-wrap items-end gap-4 mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <div class="form-group m-0 flex-grow">
                        <label for="ncrSearchField" class="text-sm">Search Field:</label>
                        <select id="ncrSearchField" class="w-full">
                            <option value="">All Fields</option>
                            <option value="ncrRefNumber">NCR Ref. Number</option>
                            <option value="ncrDiscipline">Discipline</option>
                            <option value="ncrLifecycleStatus">Lifecycle Status</option>
                            <option value="ncrDescription">NCR Description</option>
                            <option value="partAReceivedDate">Part A Received Date</option>
                            <option value="ncrRev_PartB">Part B Revision</option>
                            <option value="ncrRevisedParts_PartB">Revised Parts (Part B)</option>
                            <option value="immediateAction">Immediate Action</option>
                            <option value="rootCause">Root Cause</option>
                            <option value="correctiveAction">Corrective Action</option>
                            <option value="partBSubmittedDate">Part B Submitted Date</option>
                            <option value="partCReceivedDate">Part C Received Date</option>
                            <option value="partBAcceptedByGEC">Part B Accepted by GEC?</option>
                            <option value="ifPartBAccepted">If Part B Accepted</option>
                            <option value="partDRev">Part D Revision</option>
                            <option value="partDRevisedParts">Revised Parts (Part D)</option>
                            <option value="partDSubmittedDate">Part D Submitted Date</option>
                            <option value="partEReceivedDate">Part E Received Date</option>
                            <option value="partEStatus">Part E Status</option>
                            <option value="ncrCurrentStatus">NCR Current Status</option>
                        </select>
                    </div>
                    <div class="form-group m-0 flex-grow-[2]">
                        <label for="ncrSearchTerm" class="text-sm">Search Term:</label>
                        <input type="text" id="ncrSearchTerm" placeholder="Enter search term" class="w-full">
                    </div>
                    <div class="flex space-x-2">
                        <button class="action-button" onclick="performNcrSearch()"><i class="fas fa-search"></i> Search</button>
                        <button class="secondary-button" onclick="clearNcrSearch()"><i class="fas fa-redo"></i> Reset</button>
                    </div>
                </div>

                <div id="ncrTableContainer" class="table-container">
                    <table id="ncrTable">
                        <thead>
                            <tr>
                                <th>NCR Ref. No.</th>
                                <th>Discipline</th>
                                <th>Lifecycle Status</th>
                                <th>Description</th>
                                <th>Part A Rec. Date</th>
                                <th>Part B Rev.</th>
                                <th>Rev. Parts (B)</th>
                                <th>Imm. Action</th>
                                <th>Root Cause</th>
                                <th>Corr. Action</th>
                                <th>Part B Sub. Date</th>
                                <th>Part C Rec. Date</th>
                                <th>Part B Acc. by GEC?</th>
                                <th>If Part B Acc.</th>
                                <th>Part D Rev.</th>
                                <th>Rev. Parts (D)</th>
                                <th>Part D Sub. Date</th>
                                <th>Part E Rec. Date</th>
                                <th>Part E Status</th>
                                <th>Current Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- NCR rows will be rendered here by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Submission Register Page -->
        <div id="submissionPage" class="page-content hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Submission Register</h2>

            <!-- Form for Submissions -->
            <div class="form-section">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">Add/Edit Submission Document</h3>
                <form id="submissionForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <div class="form-group">
                        <label for="newDocNumber">Document Number:</label>
                        <input type="text" id="newDocNumber" placeholder="e.g., CP837-ENG-CIV-DRW-0001" required>
                    </div>
                    <div class="form-group">
                        <label for="newRev">Revision:</label>
                        <input type="text" id="newRev" placeholder="e.g., 0, A, B1" required>
                    </div>
                    <div class="form-group">
                        <label for="newDiscipline">Discipline:</label>
                        <select id="newDiscipline" required>
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from disciplinePrefixMap -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="newDocType">Document Type:</label>
                        <select id="newDocType" required>
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from submissionDocumentTypeOptions -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="newSection">Section (Optional):</label>
                        <input type="text" id="newSection" placeholder="e.g., Foundations">
                    </div>
                    <div class="form-group">
                        <label for="newDocTitle">Document Title:</label>
                        <textarea id="newDocTitle" rows="2" placeholder="Full title of the document" required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="newSubRef">Submission Reference (Optional):</label>
                        <input type="text" id="newSubRef" placeholder="e.g., SUB-001">
                    </div>
                    <div class="form-group">
                        <label for="newSubmittedDate">Submitted Date:</label>
                        <input type="date" id="newSubmittedDate" required>
                    </div>
                    <div class="form-group">
                        <label for="gecDueDate">GEC Due Date (Auto):</label>
                        <input type="date" id="gecDueDate" readonly class="bg-gray-100 text-gray-500">
                    </div>
                    <div class="form-group">
                        <label for="newRespondedDate">Responded Date (Optional):</label>
                        <input type="date" id="newRespondedDate">
                    </div>
                    <div class="form-group">
                        <label for="newStatus">Status:</label>
                        <select id="newStatus">
                            <option value="">--Select--</option>
                            <option value="UR">UR - Under Review</option>
                            <option value="A">A - Approved as Submitted</option>
                            <option value="B">B - Approved with Comments</option>
                            <option value="C">C - Revised and Resubmit</option>
                            <option value="D">D - Returned</option>
                            <option value="E">E - For Information</option>
                            <option value="X">X - Cancelled</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="lifecycleStatus">Lifecycle Status:</label>
                        <input type="text" id="lifecycleStatus" readonly class="bg-gray-100 text-gray-500">
                    </div>
                    <div class="form-group">
                        <label for="daysOverdue">Days Overdue:</label>
                        <input type="text" id="daysOverdue" readonly class="bg-gray-100 text-gray-500">
                    </div>

                    <div class="form-group col-span-full flex justify-end space-x-2">
                        <button type="button" class="action-button" onclick="addNewSubmissionDocument()">Add Document</button>
                        <button type="button" class="secondary-button" onclick="clearNewSubmissionDocumentForm()">Clear Form</button>
                    </div>
                </form>
            </div>

            <!-- Submission Documents Table -->
            <div id="submissionTableContainer" class="table-section mt-8">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold text-gray-700">All Submissions</h3>
                    <div class="flex space-x-2">
                        <button class="secondary-button" id="toggleSubmissionsTableBtn" onclick="toggleTableVisibility('submissionTableContainer', 'toggleSubmissionsTableBtn')">Hide Table</button>
                        <button class="action-button" onclick="downloadSubmissionCSV()">Download CSV</button>
                        <button class="secondary-button" onclick="showPivotTableOptions()">Show Pivot</button>
                    </div>
                </div>

                <!-- Search and Filter -->
                <div class="flex flex-wrap items-end gap-4 mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <div class="form-group m-0 flex-grow">
                        <label for="submissionSearchInput" class="text-sm">Search All Fields:</label>
                        <input type="text" id="submissionSearchInput" placeholder="Enter search term" class="w-full">
                    </div>
                    <div class="form-group m-0">
                        <label for="statusFilter" class="text-sm">Filter by Status:</label>
                        <select id="statusFilter" onchange="filterSubmissionByStatus(this.value)" class="w-full">
                            <option value="">All Statuses</option>
                            <option value="UR">UR - Under Review</option>
                            <option value="A">A - Approved as Submitted</option>
                            <option value="B">B - Approved with Comments</option>
                            <option value="C">C - Revised and Resubmit</option>
                            <option value="D">D - Returned</option>
                            <option value="E">E - For Information</option>
                            <option value="X">X - Cancelled</option>
                        </select>
                    </div>
                    <div class="flex space-x-2">
                        <button class="action-button" onclick="searchSubmissionDocuments()"><i class="fas fa-search"></i> Search</button>
                        <button class="secondary-button" onclick="clearSubmissionSearch()"><i class="fas fa-redo"></i> Reset Filters</button>
                    </div>
                </div>

                <div class="table-container">
                    <table id="submissionDocumentTable">
                        <thead>
                            <tr>
                                <th>Doc. No.</th>
                                <th>Rev.</th>
                                <th>Discipline</th>
                                <th>Doc. Type</th>
                                <th>Section</th>
                                <th>Doc. Title</th>
                                <th>Sub. Ref.</th>
                                <th>Submitted Date</th>
                                <th>GEC Due Date</th>
                                <th>Responded Date</th>
                                <th>Status</th>
                                <th>Lifecycle Status</th>
                                <th>Days Overdue</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Submission rows will be rendered here by JS -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Pivot Table Container (initially hidden) -->
            <div id="pivotTableContainer" class="form-section mt-8 hidden">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">Submission Status Pivot Table</h3>
                <div class="form-group flex items-center gap-4 mb-4">
                    <label for="pivotGroupingSelect" class="font-medium">Group By:</label>
                    <select id="pivotGroupingSelect" onchange="generatePivotTable()" class="flex-grow">
                        <option value="discipline">Discipline</option>
                        <option value="docType">Document Type</option>
                        <option value="section">Section</option>
                    </select>
                    <button class="secondary-button" onclick="hidePivotTable()">Hide Pivot</button>
                    <button class="action-button" onclick="downloadPivotTableCSV()">Download Pivot CSV</button>
                </div>
                <div class="table-container">
                    <table id="pivotTable">
                        <thead>
                            <!-- Pivot table headers will be rendered here by JS -->
                        </thead>
                        <tbody>
                            <!-- Pivot table rows will be rendered here by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Correspondence Register Page -->
        <div id="correspondencePage" class="page-content hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Correspondence Register</h2>

            <div class="flex tab-buttons mt-4">
                <button class="tab-button active" onclick="showCorrespondenceSection('outgoingCorrespondenceSection')">Outgoing</button>
                <button class="tab-button" onclick="showCorrespondenceSection('incomingCorrespondenceSection')">Incoming</button>
            </div>

            <!-- Outgoing Correspondence Section -->
            <div id="outgoingCorrespondenceSection" class="correspondence-section">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">Add/Edit Outgoing Correspondence</h3>
                <form id="outgoingCorrespondenceForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <div class="form-group">
                        <label for="newOutgoingInitiator">Initiator:</label>
                        <input type="text" id="newOutgoingInitiator" placeholder="e.g., GEC">
                    </div>
                    <div class="form-group">
                        <label for="newOutgoingAddressee">Addressee:</label>
                        <input type="text" id="newOutgoingAddressee" placeholder="e.g., Main Contractor">
                    </div>
                    <div class="form-group">
                        <label for="newOutgoingLetterRef">Outgoing Letter Ref.:</label>
                        <input type="text" id="newOutgoingLetterRef" placeholder="e.g., GEC-L-001" required>
                    </div>
                    <div class="form-group">
                        <label for="newOutgoingLetterDate">Letter Date:</label>
                        <input type="date" id="newOutgoingLetterDate">
                    </div>
                    <div class="form-group">
                        <label for="newOutgoingLetterSubject">Letter Subject:</label>
                        <textarea id="newOutgoingLetterSubject" rows="2" placeholder="Subject of the letter" required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="newOutgoingInReplyToRef">In Reply To Ref. (Optional):</label>
                        <input type="text" id="newOutgoingInReplyToRef" placeholder="e.g., MC-L-001">
                    </div>
                    <div class="form-group">
                        <label for="newOutgoingKeyword">Keyword:</label>
                        <select id="newOutgoingKeyword">
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from correspondenceKeywordOptions -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="newOutgoingReplyRequired">Reply Required?:</label>
                        <select id="newOutgoingReplyRequired" required>
                            <option value="">--Select--</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="newOutgoingDateSent">Date Sent:</label>
                        <input type="date" id="newOutgoingDateSent">
                    </div>
                    <div class="form-group col-span-full flex justify-end space-x-2">
                        <button type="button" class="action-button" onclick="addNewOutgoingCorrespondence()">Add Outgoing</button>
                        <button type="button" class="secondary-button" onclick="clearNewOutgoingCorrespondenceForm()">Clear Form</button>
                    </div>
                </form>

                <div class="table-section mt-8">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-semibold text-gray-700">All Outgoing Correspondences</h3>
                        <div class="flex space-x-2">
                            <button class="secondary-button" id="toggleOutgoingTableBtn" onclick="toggleTableVisibility('outgoingCorrespondenceTableContainer', 'toggleOutgoingTableBtn')">Hide Table</button>
                            <button class="action-button" onclick="downloadOutgoingCSV()">Download CSV</button>
                        </div>
                    </div>

                    <!-- Search and Filter -->
                    <div class="flex flex-wrap items-end gap-4 mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <div class="form-group m-0 flex-grow">
                            <label for="outgoingSearchInput" class="text-sm">Search All Fields:</label>
                            <input type="text" id="outgoingSearchInput" placeholder="Enter search term" class="w-full">
                        </div>
                        <div class="form-group m-0">
                            <label for="outgoingStatusFilter" class="text-sm">Filter by Status:</label>
                            <select id="outgoingStatusFilter" onchange="filterOutgoingByStatus(this.value)" class="w-full">
                                <option value="">All</option>
                                <option value="OPEN">OPEN</option>
                                <option value="CLOSED">CLOSED</option>
                            </select>
                        </div>
                        <div class="form-group m-0">
                            <label for="outgoingKeywordFilter" class="text-sm">Filter by Keyword:</label>
                            <select id="outgoingKeywordFilter" onchange="filterOutgoingByKeyword(this.value)" class="w-full">
                                <option value="">All Keywords</option>
                                <!-- Options populated by JS from correspondenceKeywordOptions -->
                            </select>
                        </div>
                        <div class="flex space-x-2">
                            <button class="action-button" onclick="searchOutgoingCorrespondences()"><i class="fas fa-search"></i> Search</button>
                            <button class="secondary-button" onclick="clearOutgoingSearch()"><i class="fas fa-redo"></i> Reset Filters</button>
                        </div>
                    </div>

                    <div id="outgoingCorrespondenceTableContainer" class="table-container">
                        <table id="outgoingCorrespondenceTable">
                            <thead>
                                <tr>
                                    <th>Initiator</th>
                                    <th>Addressee</th>
                                    <th>Letter Ref.</th>
                                    <th>Letter Date</th>
                                    <th>Letter Subject</th>
                                    <th>In Reply To Ref.</th>
                                    <th>Keyword</th>
                                    <th>Reply Required?</th>
                                    <th>Date Sent</th>
                                    <th>Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Outgoing correspondence rows will be rendered here by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Incoming Correspondence Section -->
            <div id="incomingCorrespondenceSection" class="correspondence-section hidden">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">Add/Edit Incoming Correspondence</h3>
                <form id="incomingCorrespondenceForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <div class="form-group">
                        <label for="newIncomingRef">Incoming Reference:</label>
                        <input type="text" id="newIncomingRef" placeholder="e.g., MC-L-001" required>
                    </div>
                    <div class="form-group">
                        <label for="newIncomingDateOfReceipt">Date of Receipt:</label>
                        <input type="date" id="newIncomingDateOfReceipt">
                    </div>
                    <div class="form-group">
                        <label for="newIncomingOriginator">Originator:</label>
                        <input type="text" id="newIncomingOriginator" placeholder="e.g., Main Contractor">
                    </div>
                    <div class="form-group">
                        <label for="newIncomingAddressee">Addressee:</label>
                        <input type="text" id="newIncomingAddressee" placeholder="e.g., GEC">
                    </div>
                    <div class="form-group">
                        <label for="newIncomingLetterSubject">Letter Subject:</label>
                        <textarea id="newIncomingLetterSubject" rows="2" placeholder="Subject of the letter" required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="newIncomingReplyToRef">Reply To Ref. (Optional):</label>
                        <input type="text" id="newIncomingReplyToRef" placeholder="e.g., GEC-L-001">
                    </div>
                    <div class="form-group">
                        <label for="newIncomingKeyword">Keyword:</label>
                        <select id="newIncomingKeyword">
                            <option value="">--Select--</option>
                            <!-- Options populated by JS from correspondenceKeywordOptions -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="newIncomingReplyRequired">Reply Required?:</label>
                        <select id="newIncomingReplyRequired" required>
                            <option value="">--Select--</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                    <div class="form-group col-span-full flex justify-end space-x-2">
                        <button type="button" class="action-button" onclick="addNewIncomingCorrespondence()">Add Incoming</button>
                        <button type="button" class="secondary-button" onclick="clearNewIncomingCorrespondenceForm()">Clear Form</button>
                    </div>
                </form>

                <div class="table-section mt-8">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-semibold text-gray-700">All Incoming Correspondences</h3>
                        <div class="flex space-x-2">
                            <button class="secondary-button" id="toggleIncomingTableBtn" onclick="toggleTableVisibility('incomingCorrespondenceTableContainer', 'toggleIncomingTableBtn')">Hide Table</button>
                            <button class="action-button" onclick="downloadIncomingCSV()">Download CSV</button>
                        </div>
                    </div>

                    <!-- Search and Filter -->
                    <div class="flex flex-wrap items-end gap-4 mb-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <div class="form-group m-0 flex-grow">
                            <label for="incomingSearchInput" class="text-sm">Search All Fields:</label>
                            <input type="text" id="incomingSearchInput" placeholder="Enter search term" class="w-full">
                        </div>
                        <div class="form-group m-0">
                            <label for="incomingStatusFilter" class="text-sm">Filter by Status:</label>
                            <select id="incomingStatusFilter" onchange="filterIncomingByStatus(this.value)" class="w-full">
                                <option value="">All</option>
                                <option value="OPEN">OPEN</option>
                                <option value="CLOSED">CLOSED</option>
                            </select>
                        </div>
                        <div class="form-group m-0">
                            <label for="incomingKeywordFilter" class="text-sm">Filter by Keyword:</label>
                            <select id="incomingKeywordFilter" onchange="filterIncomingByKeyword(this.value)" class="w-full">
                                <option value="">All Keywords</option>
                                <!-- Options populated by JS from correspondenceKeywordOptions -->
                            </select>
                        </div>
                        <div class="flex space-x-2">
                            <button class="action-button" onclick="searchIncomingCorrespondences()"><i class="fas fa-search"></i> Search</button>
                            <button class="secondary-button" onclick="clearIncomingSearch()"><i class="fas fa-redo"></i> Reset Filters</button>
                        </div>
                    </div>

                    <div id="incomingCorrespondenceTableContainer" class="table-container">
                        <table id="incomingCorrespondenceTable">
                            <thead>
                                <tr>
                                    <th>Incoming Ref.</th>
                                    <th>Date of Receipt</th>
                                    <th>Originator</th>
                                    <th>Addressee</th>
                                    <th>Letter Subject</th>
                                    <th>Reply To Ref.</th>
                                    <th>Keyword</th>
                                    <th>Reply Required?</th>
                                    <th>Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Incoming correspondence rows will be rendered here by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, getDoc, addDoc, setDoc, deleteDoc, onSnapshot, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Variables ---
        let inspectionsData = [];
        let mirData = [];
        let ncrData = [];
        let submissionData = [];
        let outgoingCorrespondenceData = [];
        let incomingCorrespondenceData = [];

        // Stores unsubscribe functions for Firestore listeners
        const firestoreUnsubscribes = {};

        // Not currently used for global state management with forms, can be removed if not needed
        let inspectionsEditingDocumentId = null;
        let mirEditingDocumentId = null;
        let ncrEditingDocumentId = null;
        let submissionCurrentlyEditingRowIndex = -1;
        let correspondenceCurrentlyEditingRowId = null;
        let correspondenceCurrentEditingTableType = '';

        let submissionCurrentFilterStatus = '';
        let outgoingCurrentStatusFilter = '';
        let outgoingCurrentKeywordFilter = '';
        let incomingCurrentStatusFilter = '';
        let incomingCurrentKeywordFilter = '';

        let customConfirmResolve; // To hold the resolve function for the custom confirm Promise
        let authMode = 'signIn'; // 'signIn' or 'signUp'

        // Mapping for discipline prefixes in document numbering
        const disciplinePrefixMap = {
            'Architectural': 'ARC', 'Civil': 'CIV', 'Structural': 'STR',
            'Electrical': 'ELE', 'Mechanical': 'MEC', 'Instrumentation': 'INS', 'Process': 'PRO',
            'Automation': 'AUT', 'Piping': 'PIP', 'Operations': 'OPE' // Added for submission disciplines
        };

        const submissionStatusOptions = [
            { value: "A", text: "A - Approved as Submitted" },
            { value: "B", text: "B - Approved with Comments" },
            { value: "C", text: "C - Revised and Resubmit" },
            { value: "D", text: "D - Returned" },
            { value: "UR", text: "UR - Under Review" },
            { value: "E", text: "E - For Information" },
            { value: "X", text: "X - Cancelled" }
        ];
        const submissionDocumentTypeOptions = ["MAR", "REP", "MST", "DOC", "DWG", "ASB", "ITP", "CAL", "PRQ"];
        const correspondenceKeywordOptions = [
            { value: "Audit", text: "Audit" },
            { value: "Civil", text: "Civil" },
            { value: "Closeout", text: "Closeout" },
            { value: "Commercial", text: "Commercial" },
            { value: "Commissioning", text: "Commissioning" },
            { value: "Damage", text: "Damage" },
            { value: "Delay Notice", text: "Delay Notice" },
            { value: "Design", text: "Design" },
            { value: "Dry Inspection", text: "Dry Inspection" },
            { value: "Electrical", text: "Electrical" },
            { value: "Environmental", text: "Environmental" },
            { value: "FAT", text: "FAT" },
            { value: "General", text: "General" },
            { value: "Handover", text: "Handover" },
            { value: "Handover Deliverables", text: "Handover Deliverables" },
            { value: "Health & Safety", text: "Health & Safety" },
            { value: "Joint Survey", text: "Joint Survey" },
            { value: "Kahramaa", text: "Kahramaa" },
            { value: "Material", text: "Material" },
            { value: "Mechanical", text: "Mechanical" },
            { value: "MOM", "text": "MOM" },
            { value: "NCR", text: "NCR" },
            { value: "O&M", text: "O&M" },
            { value: "Pattern Test", text: "Pattern Test" },
            { value: "PCC", "text": "PCC" },
            { value: "Performance Test", "text": "Performance Test" },
            { value: "Permit", text: "Permit" },
            { value: "Piping", text: "Piping" },
            { value: "Process", text: "Process" },
            { value: "Process Test", "text": "Process Test" },
            { value: "Procurement", text: "Procurement" },
            { value: "Programme Management", text: "Programme Management" },
            { value: "QA/QC", text: "QA/QC" },
            { value: "SAT", text: "SAT" },
            { value: "Site Acceptance", text: "Site Acceptance" },
            { value: "Site Facilities", text: "Site Facilities" },
            { value: "Site Instruction", text: "Site Instruction" },
            { value: "Snags", text: "Snags" },
            { value: "Spare Parts", text: "Spare Parts" },
            { value: "Staffing", text: "Staffing" },
            { value: "Submissions", text: "Submissions" },
            { value: "Training", text: "Training" },
            { value: "Trial Run", "text": "Trial Run" },
            { value: "Variation Order", text: "Variation Order" },
            { value: "Workmanship", text: "Workmanship" }
        ];

        // Define new status options for dropdowns
        const inspectionStatusOptions = [
            { value: "A", text: "A - Approved" },
            { value: "B", text: "B - Approved with Comments" },
            { value: "C", text: "C - Revised and Resubmit" },
            { value: "D", text: "D - Rejected" },
            { value: "UR", text: "UR - Under Review" },
            { value: "X", text: "X - Cancelled" }
        ];

        const mirApprovalStatusOptions = [
            { value: "A", text: "A - Approved" },
            { value: "B", text: "B - Approved with Comments" },
            { value: "C", text: "C - Rejected" }, // Standard for MIR rejection
            { value: "UR", text: "UR - Under Review" },
            { value: "X", text: "X - Cancelled" }
        ];

        const ncrStatuses = [
            { code: 'Open', description: 'Open' },
            { code: 'Closed', description: 'Closed' },
            { code: 'Under Review', description: 'Under Review' },
            { code: 'Pending Correction', description: 'Pending Correction' },
            { code: 'Check Latest Revision', description: 'Check Latest Revision' } // Added new option
        ];


        // Define app and database variables globally.
        let app;
        let db;
        let auth;
        let userId;
        let appId; // This will be assigned from __app_id or firebaseConfig.appId


        // --- Functions defined globally for immediate access from HTML ---
        // Tab switching logic
        function showPage(pageId) {
            document.querySelectorAll('.page-content').forEach(page => {
                page.classList.add('hidden');
            });
            document.getElementById(pageId).classList.remove('hidden');

            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`.tab-buttons button[onclick="showPage('${pageId}')"]`).classList.add('active');
        }

        // Function to show the loading overlay with a message
        function showLoadingOverlay(message = 'Loading...') {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingMessage = document.getElementById('loadingMessage');
            if (loadingOverlay && loadingMessage) {
                loadingMessage.textContent = message;
                loadingOverlay.classList.remove('hidden'); // Show by removing 'hidden'
            }
        }

        // Function to hide the loading overlay
        function hideLoadingOverlay() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden'); // Hide by adding 'hidden'
            }
        }

        // Populates fixed dropdowns
        function populateFixedDropdowns() {
            function populateSelect(selectId, options) {
                const selectElement = document.getElementById(selectId);
                if (selectElement) {
                    // Preserve the initial "--Select--" or similar option if it exists
                    let initialHtml = selectElement.querySelector('option[value=""]') ? '<option value="">--Select--</option>' : '';
                    selectElement.innerHTML = initialHtml;
                    options.forEach(option => {
                        const opt = document.createElement('option');
                        // Handle options that are objects (e.g., { value: "A", text: "..." })
                        if (typeof option === 'object' && option !== null) {
                            opt.value = option.value;
                            opt.textContent = option.text;
                        } else { // Handle options that are simple strings
                            opt.value = option;
                            opt.textContent = option;
                        }
                        selectElement.appendChild(opt);
                    });
                }
            }

            populateSelect('newDocType', submissionDocumentTypeOptions);
            populateSelect('newDiscipline', Object.keys(disciplinePrefixMap)); // Use keys for discipline select
            populateSelect('outgoingKeywordFilter', correspondenceKeywordOptions);
            populateSelect('newOutgoingKeyword', correspondenceKeywordOptions);
            populateSelect('incomingKeywordFilter', correspondenceKeywordOptions);
            populateSelect('newIncomingKeyword', correspondenceKeywordOptions);

            // Populate new dropdowns for Inspections and MIR
            populateSelect('documentStatus', inspectionStatusOptions); // For Inspections Register
            populateSelect('mirApprovalStatus', mirApprovalStatusOptions); // For MIR Register
            populateSelect('ncrCurrentStatus', ncrStatuses.map(s => ({ value: s.code, text: s.description }))); // For NCR Register
            populateSelect('discipline', Object.keys(disciplinePrefixMap)); // For Inspections Register Discipline
            populateSelect('mirDiscipline', Object.keys(disciplinePrefixMap)); // For MIR Register Discipline
            populateSelect('ncrDiscipline', Object.keys(disciplinePrefixMap)); // For NCR Register Discipline
        }

        // Custom Confirm Modal Handler - Returns a Promise
        function showCustomConfirm(message) {
            return new Promise((resolve) => {
                const modal = document.getElementById('customConfirmModal');
                const messageElement = document.getElementById('customConfirmMessage');
                if (messageElement) messageElement.textContent = message;
                if (modal) modal.classList.remove('hidden');
                customConfirmResolve = resolve; // Store the resolve function
            });
        }

        function handleCustomConfirm(response) {
            document.getElementById('customConfirmModal').classList.add('hidden');
            if (customConfirmResolve) {
                customConfirmResolve(response);
                customConfirmResolve = null; // Clear the resolve function
            }
        }

        // Custom Message Modal (for alerts)
        function showMessageModal(message, title = 'Notification') {
            const modal = document.getElementById('messageModal');
            const titleElement = document.getElementById('messageModalTitle');
            const messageElement = document.getElementById('messageModalMessage');
            if (titleElement) titleElement.textContent = title;
            if (messageElement) messageElement.textContent = message;
            if (modal) modal.classList.remove('hidden');
        }

        function hideMessageModal() {
            const modal = document.getElementById('messageModal');
            if (modal) modal.classList.add('hidden');
        }

        // Forgot Password Modal functions
        function showForgotPasswordModal() {
            document.getElementById('forgotPasswordModal').classList.remove('hidden');
            document.getElementById('resetEmail').value = document.getElementById('authEmail').value; // Pre-fill with login email
        }

        function hideForgotPasswordModal() {
            document.getElementById('forgotPasswordModal').classList.add('hidden');
            document.getElementById('resetEmail').value = ''; // Clear email field
        }

        async function sendPasswordReset() {
            const email = document.getElementById('resetEmail').value;
            if (!email) {
                showMessageModal("Please enter your email address to reset your password.", "Missing Email");
                return;
            }
            if (!auth) {
                showMessageModal("Firebase Authentication is not ready. Please wait a moment and try again.", "Initialization Error");
                return;
            }

            showLoadingOverlay('Sending password reset email...');
            try {
                await sendPasswordResetEmail(auth, email);
                hideForgotPasswordModal(); // Close the reset modal
                showMessageModal("A password reset link has been sent to your email address.", "Password Reset Sent");
            } catch (error) {
                console.error("Password reset error:", error);
                let errorMessage = "Failed to send password reset email.";
                if (error.code === 'auth/user-not-found') {
                    errorMessage = "No user found with that email address. Please check your email or sign up.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "The email address is not valid.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Network error. Please check your internet connection.";
                } else {
                    errorMessage += " " + error.message;
                }
                showMessageModal(errorMessage, "Password Reset Failed");
            } finally {
                hideLoadingOverlay();
            }
        }

        // Toggle table visibility
        function toggleTableVisibility(tableContainerId, buttonId) {
            const tableContainer = document.getElementById(tableContainerId);
            const button = document.getElementById(buttonId);
            if (tableContainer.classList.contains('hidden')) {
                tableContainer.classList.remove('hidden');
                button.textContent = 'Hide Table';
            } else {
                tableContainer.classList.add('hidden');
                button.textContent = 'Show Table';
            }
        }

        // Function to switch between Outgoing/Incoming correspondence forms and tables
        function showCorrespondenceSection(sectionId) {
            document.querySelectorAll('.correspondence-section').forEach(section => {
                section.classList.add('hidden');
            });
            document.getElementById(sectionId).classList.remove('hidden');

            document.querySelectorAll('#correspondencePage .tab-buttons .tab-button').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`#correspondencePage .tab-buttons button[onclick="showCorrespondenceSection('${sectionId}')"]`).classList.add('active');
        }


        // --- UI State Management (Enable/Disable Firestore-related elements) ---
        // This function targets specific elements for disabling interactivity.
        // It now applies to elements within #appContainer that are meant to be controlled.
        function disableFirestoreUI() {
            const appContentElements = document.querySelectorAll('#appContainer input, #appContainer select, #appContainer textarea, #appContainer button, #appContainer .tab-button');
            appContentElements.forEach(element => {
                element.style.opacity = '0.5';
                element.style.pointerEvents = 'none';
            });
        }

        function enableFirestoreUI() {
            const appContentElements = document.querySelectorAll('#appContainer input, #appContainer select, #appContainer textarea, #appContainer button, #appContainer .tab-button');
            appContentElements.forEach(element => {
                element.style.pointerEvents = 'auto';
                element.style.opacity = '1';
            });
        }

        // --- Firebase Initialization and Authentication ---

        // Function to show/hide the main app and authentication container
        function toggleAppUI(isAuthenticated) {
            const authContainer = document.getElementById('authContainer');
            const appContainer = document.getElementById('appContainer');

            if (isAuthenticated) {
                if (authContainer) authContainer.classList.add('hidden');
                if (appContainer) appContainer.classList.remove('hidden');
                enableFirestoreUI(); // Enable main app UI when authenticated
            } else {
                if (authContainer) authContainer.classList.remove('hidden');
                if (appContainer) appContainer.classList.add('hidden');
                // We don't disable authContainer inputs here; they should always be active
                disableFirestoreUI(); // Disable main app UI when not authenticated
            }
        }

        // Toggle between Sign In and Sign Up modes
        function toggleAuthMode() {
            const authTitle = document.getElementById('authTitle');
            const authSubmitButton = document.getElementById('authSubmitButton');
            const toggleAuthMessage = document.querySelector('.toggle-mode-link'); // Select the paragraph element

            if (authMode === 'signIn') {
                authMode = 'signUp';
                authTitle.textContent = 'Sign Up';
                authSubmitButton.textContent = 'Sign Up';
                toggleAuthMessage.innerHTML = 'Already have an account? <button onclick="toggleAuthMode()" class="text-blue-600 hover:underline">Sign In</button>';
            } else {
                authMode = 'signIn';
                authTitle.textContent = 'Sign In';
                authSubmitButton.textContent = 'Sign In';
                toggleAuthMessage.innerHTML = "Don't have an account? <button onclick=\"toggleAuthMode()\" class=\"text-blue-600 hover:underline\">Sign Up</button>";
            }
        }

        // Handle Sign In / Sign Up submission
        async function handleAuthSubmit() {
            const email = document.getElementById('authEmail').value;
            const password = document.getElementById('authPassword').value;

            // Ensure auth object is initialized
            if (!auth) {
                showMessageModal("Firebase Authentication is not ready. Please wait a moment and try again.", "Initialization Error");
                return;
            }

            if (!email || !password) {
                showMessageModal("Please enter both email and password.", "Missing Credentials");
                return;
            }

            if (authMode === 'signUp') {
                await handleSignUp(email, password);
            } else {
                await handleSignIn(email, password);
            }
        }

        // Handle Email/Password Sign Up
        async function handleSignUp(email, password) {
            showLoadingOverlay('Signing up...');
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                showMessageModal("Account created successfully! You are now signed in.", "Success");
                // onAuthStateChanged will handle UI update
            } catch (error) {
                console.error("Sign Up Error:", error);
                let errorMessage = "Failed to create account.";
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "This email is already in use. Please sign in or use a different email.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Password is too weak. Please choose a stronger password (at least 6 characters).";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email address.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Email/Password sign-up is not enabled. Please enable it in your Firebase project's Authentication settings.";
                }
                showMessageModal(errorMessage, "Sign Up Failed");
            } finally {
                hideLoadingOverlay();
            }
        }

        // Handle Email/Password Sign In
        async function handleSignIn(email, password) {
            showLoadingOverlay('Signing in...');
            try {
                await signInWithEmailAndPassword(auth, email, password);
                showMessageModal("Signed in successfully!", "Success");
                // onAuthStateChanged will handle UI update
            } catch (error) {
                console.error("Sign In Error:", error);
                let errorMessage = "Failed to sign in.";
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                    errorMessage = "Invalid email or password.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email address.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Email/Password sign-in is not enabled. Please enable it in your Firebase project's Authentication settings.";
                }
                showMessageModal(errorMessage, "Sign In Failed");
            } finally {
                hideLoadingOverlay();
            }
        }

        // Handle Sign Out
        async function handleSignOut() {
            showLoadingOverlay('Signing out...');
            try {
                await signOut(auth);
                // Clear the auth form fields after successful sign-out
                document.getElementById('authEmail').value = '';
                document.getElementById('authPassword').value = '';
                showMessageModal("Signed out successfully. You can sign in again or continue anonymously.", "Signed Out");
                // onAuthStateChanged will handle UI update
            } catch (error) {
                console.error("Sign Out Error:", error);
                showMessageModal("Failed to sign out: " + error.message, "Error");
            } finally {
                hideLoadingOverlay();
            }
        }

        // Anonymous Sign In
        async function signInAnonymouslyUser() {
            showLoadingOverlay('Signing in anonymously...');
            // Ensure auth object is initialized
            if (!auth) {
                showMessageModal("Firebase Authentication is not ready. Please wait a moment and try again.", "Initialization Error");
                return;
            }
            try {
                await signInAnonymously(auth);
                // onAuthStateChanged will handle UI update
            } catch (error) {
                console.error("Anonymous Sign In Error:", error);
                let errorMessage = "Failed to sign in anonymously. ";
                if (error.code === 'auth/operation-not-allowed') {
                    errorMessage += "Anonymous authentication is not enabled. Please enable it in your Firebase project's Authentication settings.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage += "Network error. Please check your internet connection.";
                } else {
                    errorMessage += error.message;
                }
                showMessageModal(errorMessage, "Authentication Error");
                disableFirestoreUI();
            } finally {
                hideLoadingOverlay();
            }
        }

        async function initializeFirebaseAndAuth() {
            showLoadingOverlay('Connecting to Firebase...');
            console.log("Starting Firebase initialization...");

            const displayUserIdSpan = document.getElementById('displayUserId');
            const appIdStatusSpan = document.getElementById('appIdStatus');
            const firebaseConfigStatusSpan = document.getElementById('firebaseConfigStatus');

            // Set initial statuses
            if (displayUserIdSpan) displayUserIdSpan.textContent = 'Authenticating...';
            if (appIdStatusSpan) appIdStatusSpan.textContent = 'Checking...';
            if (firebaseConfigStatusSpan) firebaseConfigStatusSpan.textContent = 'Checking...';

            let firebaseConfigParsed;
            let configSource = 'Hardcoded (Fallback)'; // Default source

            // Use the __firebase_config from the Canvas environment, or fallback to the hardcoded config for local testing
            if (typeof __firebase_config !== 'undefined' && __firebase_config) {
                try {
                    firebaseConfigParsed = JSON.parse(__firebase_config);
                    configSource = 'Canvas Environment';
                } catch (e) {
                    console.error("Error parsing __firebase_config from Canvas environment:", e);
                    firebaseConfigParsed = {
                        apiKey: "AIzaSyA8oy4qdXi8Us_wPvAVMv0pR46qbh2B3LM", // <-- REPLACE WITH YOUR ACTUAL API KEY
                        authDomain: "document-control-register.firebaseapp.com", // <-- REPLACE WITH YOUR ACTUAL AUTH DOMAIN
                        projectId: "document-control-register", // <-- REPLACE WITH YOUR ACTUAL PROJECT ID
                        storageBucket: "document-control-register.firebasestorage.app", // <-- REPLACE WITH YOUR ACTUAL STORAGE BUCKET
                        messagingSenderId: "1073131236663", // <-- REPLACE WITH YOUR ACTUAL MESSAGING SENDER ID
                        appId: "1:1073131236663:web:0c72a5ab59e23e30c3feb2", // <-- REPLACE WITH YOUR ACTUAL APP ID
                        measurementId: "G-SGJPX3X791" // <-- REPLACE WITH YOUR ACTUAL MEASUREMENT ID
                    };
                    console.warn("Falling back to hardcoded firebaseConfig due to Canvas config parsing error. IMPORTANT: Please replace this with your actual Firebase project config from the Firebase Console if you encounter authentication issues.");
                }
            } else {
                console.warn("__firebase_config is undefined or empty. Falling back to hardcoded firebaseConfig for local testing. IMPORTANT: Please replace this with your actual Firebase project config from the Firebase Console if you encounter authentication issues.");
                firebaseConfigParsed = {
                    apiKey: "AIzaSyA8oy4qdXi8Us_wPvAVMv0pR46qbh2B3LM", // <-- REPLACE WITH YOUR ACTUAL API KEY
                    authDomain: "document-control-register.firebaseapp.com", // <-- REPLACE WITH YOUR ACTUAL AUTH DOMAIN
                    projectId: "document-control-register", // <-- REPLACE WITH YOUR ACTUAL PROJECT ID
                    storageBucket: "document-control-register.firebasestorage.app", // <-- REPLACE WITH YOUR ACTUAL STORAGE BUCKET
                    messagingSenderId: "1073131236663", // <-- REPLACE WITH YOUR ACTUAL MESSAGING SENDER ID
                    appId: "1:1073131236663:web:0c72a5ab59e23e30c3feb2", // <-- REPLACE WITH YOUR ACTUAL APP ID
                    measurementId: "G-SGJPX3X791" // <-- REPLACE WITH YOUR ACTUAL MEASUREMENT ID
                };
            }

            // Log the Firebase config being used for verification
            console.log("Firebase config being used:", firebaseConfigParsed);

            // The __app_id variable is provided by the Canvas environment for the Firestore path.
            // This is distinct from the appId property within the firebaseConfig object itself.
            appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfigParsed.appId;

            // Update App ID Status
            if (appId && appId !== 'default-app-id' && !appId.includes('YOUR_APP_ID')) {
                if (appIdStatusSpan) {
                    appIdStatusSpan.textContent = `Set: ${appId}`;
                    appIdStatusSpan.classList.add('ok');
                    appIdStatusSpan.classList.remove('error');
                }
                console.log("App ID detected:", appId);
            } else {
                if (appIdStatusSpan) {
                    appIdStatusSpan.textContent = 'Not Found (Using Fallback)';
                    appIdStatusSpan.classList.add('error');
                    appIdStatusSpan.classList.remove('ok');
                }
                console.warn("App ID is not found in Canvas environment or firebaseConfig. Using fallback appId from firebaseConfig.");
            }

            if (firebaseConfigStatusSpan) {
                firebaseConfigStatusSpan.textContent = `Using: ${configSource}`;
                firebaseConfigStatusSpan.classList.add('ok'); // Assume OK unless initialization fails
                firebaseConfigStatusSpan.classList.remove('error');
            }

            try {
                // Initialize Firebase app and services using the parsed config
                app = initializeApp(firebaseConfigParsed);
                auth = getAuth(app);
                db = getFirestore(app);

                console.log("Firebase services initialized successfully.");
                if (firebaseConfigStatusSpan) {
                    firebaseConfigStatusSpan.textContent = `${configSource} (Initialized OK)`;
                    firebaseConfigStatusSpan.classList.add('ok');
                    firebaseConfigStatusSpan.classList.remove('error');
                }

                // Set up the onAuthStateChanged listener first
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        // User is signed in.
                        userId = user.uid;
                        console.log(`[Auth State] User signed in with UID: ${userId} (Auth type: ${user.isAnonymous ? 'Anonymous' : 'Email/Password'})`);
                        if (displayUserIdSpan) displayUserIdSpan.textContent = userId;
                        console.log(`Current userId: ${userId}, Current appId: ${appId}`);
                        toggleAppUI(true); // Show main app UI and enable its interactive elements
                        await loadAllDataListeners();
                        // Provide more specific guidance about anonymous sessions and data persistence
                        let persistenceMessage = "Welcome! Your data is being loaded.";
                        if (user.isAnonymous) {
                            persistenceMessage += " Please note that data saved under an anonymous session might be lost if you clear 'All Site Data' or 'Cookies and other site data' in your browser.";
                            // For anonymous users, prompt them to consider signing up
                            showMessageModal(persistenceMessage + " For permanent data, please sign up with email and password.", "Welcome Back (Anonymous)");
                        } else {
                            showMessageModal(persistenceMessage, "Welcome Back!");
                        }
                    } else {
                        // User is signed out or not yet signed in.
                        console.log("[Auth State] No user found or signed out. Displaying authentication options.");
                        toggleAppUI(false); // Hide main app UI, show auth UI and disable main app interactive elements
                        if (displayUserIdSpan) displayUserIdSpan.textContent = 'Not Authenticated';
                        // Detach all Firestore listeners when no user is authenticated
                        detachAllFirestoreListeners();
                        // The auth inputs are not disabled by disableFirestoreUI()
                        // Attempt to sign in with custom token only if provided by Canvas
                        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                        if (initialAuthToken) {
                            console.log("Attempting sign-in with custom token...");
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } catch (tokenError) {
                                console.error("Custom token sign-in failed:", tokenError);
                                showMessageModal('Custom token sign-in failed. Please ensure Firebase Auth is properly configured: ' + tokenError.message, 'Authentication Error');
                            }
                        }
                    }
                    hideLoadingOverlay(); // Hide overlay after the auth state is processed
                });

            } catch (error) {
                console.error("Critical error during Firebase app or service initialization:", error);
                if (displayUserIdSpan) displayUserIdSpan.textContent = 'Error: Firebase Init Failed';
                if (firebaseConfigStatusSpan) {
                    firebaseConfigStatusSpan.textContent = 'Initialization Failed';
                    firebaseConfigStatusSpan.classList.add('error');
                    firebaseConfigStatusSpan.classList.remove('ok');
                }
                showMessageModal(
                    'A critical error occurred while initializing Firebase. Please check the console for details ' +
                    'and ensure your Firebase setup is correct. Data persistence will not work.',
                    'Critical Error'
                );
                disableFirestoreUI(); // Ensure app UI is disabled on critical init failure
                hideLoadingOverlay(); // Ensure overlay is hidden even on critical init failure
            }
        }

        // Function to detach all active Firestore real-time listeners
        function detachAllFirestoreListeners() {
            for (const collectionName in firestoreUnsubscribes) {
                if (typeof firestoreUnsubscribes[collectionName] === 'function') {
                    firestoreUnsubscribes[collectionName](); // Call the unsubscribe function
                    console.log(`[Firestore] Detached listener for ${collectionName}`);
                }
            }
            // Optionally, clear the data arrays if they should be empty on sign-out
            inspectionsData = [];
            mirData = [];
            ncrData = [];
            submissionData = [];
            outgoingCorrespondenceData = [];
            incomingCorrespondenceData = [];

            // Re-render tables to show empty state
            performInspectionsSearch();
            performMirSearch();
            performNcrSearch();
            searchSubmissionDocuments();
            searchOutgoingCorrespondences();
            searchIncomingCorrespondences();
        }

        // --- Utility Functions ---

        /**
         * Helper to compare revisions (e.g., "0" < "1", "A" < "B", "1" < "1A").
         * This function attempts numerical comparison first, then falls back to string comparison
         * with a locale-aware, numeric-sensitive approach.
         * Returns:
         * -1 if rev1 is less than rev2
         * 0 if rev1 is equal to rev2
         * 1 if rev1 is greater than rev2
         */
        function compareRevisions(rev1, rev2) {
            // Treat empty/null revisions as the earliest possible
            if (!rev1 && !rev2) return 0;
            if (!rev1) return -1; // rev1 is earlier
            if (!rev2) return 1;  // rev2 is earlier

            if (rev1 === rev2) return 0;

            // Try numerical comparison first if both are purely numerical
            const num1 = parseInt(rev1, 10);
            const num2 = parseInt(rev2, 10);

            if (!isNaN(num1) && !isNaN(num2) && String(num1) === rev1 && String(num2) === rev2) {
                if (num1 !== num2) return num1 - num2;
            }

            // Fallback to localeCompare with numeric and sensitivity options
            return rev1.localeCompare(rev2, undefined, { numeric: true, sensitivity: 'base' });
        }

        /**
         * Calculates the next logical revision based on the current one.
         * Handles numerical (e.g., "0" -> "1", "9" -> "10") and alphabetical (e.g., "A" -> "B", "Z" -> "AA") increments.
         * Specifically for NCR Part B, starts with '0' if no prior revision.
         * @param {string} currentRev The current revision string (e.g., "0", "1", "A", "Z", "AA"). Can be empty/null.
         * @returns {string} The next logical revision.
         */
        function getNextRevision(currentRev) {
            if (!currentRev) {
                return '0'; // Default starting revision for Part B
            }

            // Try numerical increment
            const numRev = parseInt(currentRev, 10);
            if (!isNaN(numRev) && String(numRev) === currentRev) { // Ensure it's purely numerical
                return String(numRev + 1);
            }

            // Try alphabetical increment (A -> B, Z -> AA)
            const lastChar = currentRev.slice(-1);
            const prefix = currentRev.slice(0, -1);

            if (lastChar.match(/[A-Z]/i)) {
                const charCode = lastChar.toUpperCase().charCodeAt(0);
                if (charCode === 90) { // 'Z'
                    // Recurse for the prefix and append 'A' for carry-over
                    if (prefix) {
                        return getNextRevision(prefix) + 'A';
                    } else {
                        return 'AA'; // Z -> AA
                    }
                } else {
                    return prefix + String.fromCharCode(charCode + 1);
                }
            }

            // Fallback for mixed or unhandled formats (e.g., "1A" -> "1B")
            const mixedMatch = currentRev.match(/^(\d+)([A-Z]+)$/i);
            if (mixedMatch) {
                const numPart = mixedMatch[1];
                const alphaPart = mixedMatch[2];
                const lastAlphaChar = alphaPart.slice(-1);
                const alphaPrefix = alphaPart.slice(0, -1);
                const charCode = lastAlphaChar.toUpperCase().charCodeAt(0);
                if (charCode === 90) {
                    return numPart + getNextRevision(alphaPart);
                } else {
                    return numPart + alphaPrefix + String.fromCharCode(charCode + 1);
                }
            }

            return currentRev + '-next'; // Fallback if no clear pattern
        }


        async function generateNextDocNumber(collectionName, prefix, numberField, discipline = '') {
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                console.warn("Firebase, User ID, or App ID not ready for generating next doc number. Returning fallback message.");
                return 'Loading...';
            }

            const colRef = collection(db, `/artifacts/${appId}/users/${userId}/${collectionName}`);
            let maxNumber = 0;

            try {
                const querySnapshot = await getDocs(colRef);
                querySnapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    if (data[numberField]) {
                        const parts = String(data[numberField]).split('-');
                        if (parts.length > 0) {
                            const lastPart = parts[parts.length - 1];
                            // Extract numeric part from revision, e.g., "0001" from "CP837-INS-CIV-0001"
                            const num = parseInt(lastPart, 10);
                            if (!isNaN(num) && num > maxNumber) {
                                maxNumber = num;
                            }
                        }
                    }
                });
            } catch (error) {
                console.error("Error fetching documents for next number generation:", error);
                return 'Error';
            }

            const nextNumber = maxNumber + 1;
            const formattedNumber = String(nextNumber).padStart(4, '0');
            if (discipline && disciplinePrefixMap[discipline]) {
                // Example: CP837-INS-CIV-0001
                return `${prefix}-${disciplinePrefixMap[discipline]}-${formattedNumber}`;
            }
            // Fallback for cases where discipline is not selected or not in map
            if (prefix.includes('-')) { // If prefix already has discipline part like CP837-MIR
                return `${prefix.substring(0, prefix.lastIndexOf('-')+1)}${formattedNumber}`;
            }
            return `${prefix}-${formattedNumber}`;
        }


        function calculateDaysOverdue(submittedDate, respondedDate) {
            if (!submittedDate) return '';

            const subDate = new Date(submittedDate);
            const dueDate = new Date(subDate);
            dueDate.setDate(subDate.getDate() + 14); // GEC due date is 14 days after submission

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let actualResponseDate = respondedDate ? new Date(respondedDate) : today;
            actualResponseDate.setHours(0, 0, 0, 0);

            if (actualResponseDate > dueDate) {
                const diffTime = Math.abs(actualResponseDate.getTime() - dueDate.getTime());
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                return diffDays;
            }
            return 0;
        }

        /**
         * Formats a date string into MM/DD/YYYY format for display in tables and CSV.
         * Handles ISO (YYYY-MM-DD), MM/DD/YYYY, and DD-MM-YYYY inputs.
         * Returns an empty string if the date is invalid or null.
         * @param {string} dateString The date string to format.
         * @returns {string} The formatted date string (MM/DD/YYYY) or an empty string.
         */
        function formatDateForDisplay(dateString) {
            if (!dateString) {
                return '';
            }

            let date;
            // Try parsing as ISO format (YYYY-MM-DD) first, as it's common from input fields or storage
            if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                date = new Date(dateString + 'T00:00:00'); // Add T00:00:00 to avoid timezone issues
            }
            // Try parsing as DD-MM-YYYY
            else if (dateString.match(/^\d{2}-\d{2}-\d{4}$/)) {
                const parts = dateString.split('-');
                // Note: Month is 0-indexed in JavaScript Date object
                date = new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
            }
            // Try parsing as MM/DD/YYYY
            else if (dateString.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
                date = new Date(dateString);
            }
            // Fallback for any other string format Date constructor might handle
            else {
                date = new Date(dateString);
            }

            // Check if the date is valid after parsing
            if (isNaN(date.getTime())) {
                console.warn("Invalid date string encountered in formatDateForDisplay:", dateString);
                return ''; // Return empty string for invalid dates
            }

            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
            const year = date.getFullYear();

            // Ensure MM/DD/YYYY format
            return `${month}/${day}/${year}`;
        }

        /**
         * Formats a date string into YYYY-MM-DD format for HTML date input fields.
         * Handles ISO (YYYY-MM-DD), MM/DD/YYYY, and DD-MM-YYYY inputs.
         * Returns an empty string if the date is invalid or null.
         * @param {string} dateString The date string to format.
         * @returns {string} The formatted date string (YYYY-MM-DD) or an empty string.
         */
        function formatDateForInput(dateString) {
            if (!dateString) {
                return '';
            }

            let date;
            // Try parsing as ISO format (YYYY-MM-DD) first, as it's common from storage
            if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                date = new Date(dateString + 'T00:00:00'); // Add T00:00:00 to avoid timezone issues
            }
            // Try parsing as DD-MM-YYYY
            else if (dateString.match(/^\d{2}-\d{2}-\d{4}$/)) {
                const parts = dateString.split('-');
                date = new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
            }
            // Try parsing as MM/DD/YYYY
            else if (dateString.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
                date = new Date(dateString);
            }
            // Fallback for any other string format Date constructor might handle
            else {
                date = new Date(dateString);
            }

            // Check if the date is valid after parsing
            if (isNaN(date.getTime())) {
                console.warn("Invalid date string encountered in formatDateForInput:", dateString);
                return ''; // Return empty string for invalid dates
            }

            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
            const year = date.getFullYear();

            // Return YYYY-MM-DD format
            return `${year}-${month}-${day}`;
        }


        // calculateRevStatus needs to be reframed as it now calculates the "Latest, Approved" style summary,
        // while `revStatus` field itself will hold the "Latest"/"Superseded" lifecycle status.
        // Let's create a new function `getApprovalSummaryText` for the text summary.
        function getApprovalSummaryText(statusCode) {
            const statusMap = {
                "A": "Approved",
                "B": "Approved with Comments",
                "C": "Revised & Resubmit",
                "D": "Returned", // Inspections, Submissions
                "UR": "Under Review",
                "E": "For Information", // Submissions
                "X": "Cancelled",
                // For MIR specific statuses
                "Hold": "Hold"
            };
            return statusMap[statusCode] || statusCode || '';
        }

        // --- Data Management (Firestore) ---

        async function saveDocument(collectionName, docId, data) {
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                console.error(`[Firestore Check] Firestore not ready for saving document to ${collectionName}. DB: ${db}, User ID: ${userId}, App ID: ${appId}`);
                showMessageModal("Data persistence is not available. Please ensure Firebase is correctly configured and authenticated.", "Error Saving Data");
                return { success: false, error: new Error("Firestore or User ID or App ID not ready.") };
            }
            showLoadingOverlay('Saving document...');
            const docRefPath = `/artifacts/${appId}/users/${userId}/${collectionName}`;
            console.log(`[Firestore] Attempting to save document to path: ${docRefPath} with ID: ${docId}`);

            try {
                const savePromise = setDoc(doc(db, docRefPath, docId), data, { merge: true });
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Firestore save operation timed out')), 15000) // 15 seconds
                );
                await Promise.race([savePromise, timeoutPromise]);

                console.log(`[Firestore] Document saved successfully to ${collectionName} with ID: ${docId}`);
                return { success: true, id: docId };
            } catch (e) {
                console.error(`[Firestore Error] Error adding/updating document in ${collectionName} with ID ${docId}: `, e);
                showMessageModal("Error saving document: " + e.message, "Error");
                return { success: false, error: e };
            } finally {
                hideLoadingOverlay();
            }
        }

        async function addDocument(collectionName, data) {
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                console.error(`[Firestore Check] Firestore not ready for adding document to ${collectionName}. DB: ${db}, User ID: ${userId}, App ID: ${appId}`);
                showMessageModal("Data persistence is not available. Please ensure Firebase is correctly configured and authenticated.", "Error Adding Data");
                return { success: false, error: new Error("Firestore or User ID or App ID not ready.") };
            }
            showLoadingOverlay('Adding new document...');
            const colRefPath = `/artifacts/${appId}/users/${userId}/${collectionName}`;
            console.log(`[Firestore] Attempting to add document to collection path: ${colRefPath}`);

            try {
                const addPromise = addDoc(collection(db, colRefPath), data);
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Firestore add operation timed out')), 15000) // 15 seconds
                );
                const docRef = await Promise.race([addPromise, timeoutPromise]);

                console.log(`[Firestore] New document added to ${collectionName} with ID: ${docRef.id}`);
                return { success: true, id: docRef.id };
            } catch (e) {
                console.error(`[Firestore Error] Error adding new document to ${collectionName}: `, e);
                showMessageModal("Error adding document: " + e.message, "Error");
                return { success: false, error: e };
            } finally {
                hideLoadingOverlay();
            }
        }

        // CORRECTED: The `deleteDocument` function
        async function deleteDocument(collectionName, docId) {
            // Use the custom confirmation modal
            const confirmDelete = await showCustomConfirm('Are you sure you want to delete this document? This action cannot be undone.');
            if (!confirmDelete) {
                showMessageModal("Document deletion cancelled.", "Cancelled");
                return { success: false, error: new Error("User cancelled deletion.") };
            }

            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                console.error(`[Firestore Check] Firestore not ready for deleting document from ${collectionName}. DB: ${db}, User ID: ${userId}, App ID: ${appId}`);
                showMessageModal("Data persistence is not available. Please ensure Firebase is correctly configured and authenticated.", "Error Deleting Data");
                return { success: false, error: new Error("Firestore or User ID or App ID not ready.") };
            }
            showLoadingOverlay('Deleting document...');
            try {
                const docPath = `/artifacts/${appId}/users/${userId}/${collectionName}`;
                console.log(`[Firestore] Attempting to delete document from path: ${docPath} with ID: ${docId}`);

                const deletePromise = deleteDoc(doc(db, docPath, docId));
                const timeoutPromise = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Firestore delete operation timed out')), 15000) // 15 seconds
                );
                await Promise.race([deletePromise, timeoutPromise]);

                console.log(`[Firestore] Document deleted from ${collectionName} with ID: ${docId}`);
                showMessageModal("Document deleted successfully!", "Success");
                return { success: true };
            } catch (e) {
                console.error(`[Firestore Error] Error deleting document: `, e);
                showMessageModal("Error deleting document: " + e.message, "Error");
                return { success: false, error: e };
            } finally {
                hideLoadingOverlay();
            }
        }

        function setupRealtimeListener(collectionName) {
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                console.warn(`[Firestore Check] Skipping listener setup for ${collectionName}: Firestore, User ID, or App ID not ready.`);
                return;
            }

            const colRefPath = `/artifacts/${appId}/users/${userId}/${collectionName}`;
            const colRef = collection(db, colRefPath);
            console.log(`[Firestore] Setting up real-time listener for: ${colRefPath}`);

            // Store the unsubscribe function
            firestoreUnsubscribes[collectionName] = onSnapshot(colRef, (snapshot) => {
                let documents = [];
                snapshot.forEach(docSnap => {
                    documents.push({ id: docSnap.id, ...docSnap.data() });
                });

                // Update the global data array and re-render the corresponding table
                switch(collectionName) {
                    case 'inspections': inspectionsData = documents; performInspectionsSearch(); break;
                    case 'mir': mirData = documents; performMirSearch(); break;
                    case 'ncr': ncrData = documents; performNcrSearch(); break; // NCR logic updated here
                    case 'submissions': submissionData = documents; searchSubmissionDocuments(); break;
                    case 'outgoing_correspondences': outgoingCorrespondenceData = documents; searchOutgoingCorrespondences(); break;
                    case 'incoming_correspondences': incomingCorrespondenceData = documents; searchIncomingCorrespondences(); break;
                }

                console.log(`[Firestore] Loaded ${documents.length} documents for ${collectionName}`);
            }, (error) => {
                console.error(`[Firestore Error] Error listening to ${collectionName}:`, error);
                showMessageModal(`Error loading data for ${collectionName}: ${error.message}`, "Data Load Error");
            });
        }

        // --- Specific Register Functions (Add/Update/Edit/Clear) ---

        async function addUpdateInspectionDocument() {
            console.log("[Inspections] Starting addUpdateInspectionDocument...");
            const form = document.getElementById('inspectionForm');
            const docId = form.dataset.docId;

            const data = {
                date: document.getElementById('date').value,
                insNumber: document.getElementById('insNumber').value,
                revision: document.getElementById('revision').value,
                discipline: document.getElementById('discipline').value,
                location: document.getElementById('location').value,
                // Removed submissionType
                workToBeInspected: document.getElementById('workToBeInspected').value,
                inspectionDate: document.getElementById('inspectionDate').value,
                inspectionTime: document.getElementById('inspectionTime').value,
                approvedDrawingRef: document.getElementById('approvedDrawingRef').value,
                specificationRef: document.getElementById('specificationRef').value,
                approvedMethodStatementRef: document.getElementById('approvedMethodStatementRef').value,
                qcsReference: document.getElementById('qcsReference').value,
                commentReceivedDate: document.getElementById('commentReceivedDate').value,
                // These are the selected status from the dropdown
                documentStatus: document.getElementById('documentStatus').value,
                // This is the lifecycle status: 'Latest' or 'Superseded'
                revStatus: '', // Will be determined by logic below
                // This is the approval text for display, not directly stored as 'revStatus'
                approvalSummaryStatus: getApprovalSummaryText(document.getElementById('documentStatus').value)
            };

            if (!data.date || !data.insNumber || !data.revision || !data.discipline || !data.documentStatus) {
                showMessageModal("Please fill in all required fields: Date, INS Number, Revision, Discipline, and Document Status.", "Missing Information");
                console.warn("[Inspections] Required fields missing. Operation aborted.");
                return;
            }

            try {
                let result;
                if (docId) {
                    // If editing an existing document, just update its content.
                    // Its lifecycle status ('Latest'/'Superseded') should not change here.
                    console.log(`[Inspections] Updating existing document with ID: ${docId}`, data);
                    // Retain the existing revStatus (lifecycle status)
                    const currentDoc = inspectionsData.find(d => d.id === docId);
                    if (currentDoc) {
                        data.revStatus = currentDoc.revStatus;
                    }
                    result = await saveDocument('inspections', docId, data);
                } else {
                    // Adding a new document or a new revision
                    console.log("[Inspections] Adding new document or new revision:", data);

                    // Find any existing "Latest" inspection for this INS Number and Discipline
                    const existingLatestInspections = inspectionsData.filter(d =>
                        d.insNumber === data.insNumber &&
                        d.discipline === data.discipline &&
                        d.revStatus === 'Latest' // Only consider documents explicitly marked 'Latest'
                    );

                    let previousLatestDoc = null;
                    if (existingLatestInspections.length > 0) {
                        // Sort by revision to ensure we get the absolute latest if multiple 'Latest' somehow exist
                        existingLatestInspections.sort((a, b) => compareRevisions(a.revision, b.revision));
                        previousLatestDoc = existingLatestInspections[existingLatestInspections.length - 1];
                    }

                    if (previousLatestDoc && compareRevisions(data.revision, previousLatestDoc.revision) > 0) {
                        // If a previous 'Latest' exists and the new revision is indeed higher, supersede the old one.
                        console.log(`[Inspections] Marking previous latest inspection (${previousLatestDoc.id}) as Superseded.`);
                        await saveDocument('inspections', previousLatestDoc.id, { revStatus: 'Superseded' });
                    } else if (previousLatestDoc && compareRevisions(data.revision, previousLatestDoc.revision) < 0) {
                        // Handle case where new revision is older than existing latest
                        showMessageModal("The revision you are adding is older than an existing 'Latest' revision for this INS Number and Discipline. Please check the revision number.", "Warning: Older Revision");
                        data.revStatus = 'Superseded'; // Treat older revisions as superseded by default
                    }

                    // The newly added document is always the new 'Latest' or the first document in its series.
                    data.revStatus = 'Latest';

                    result = await addDocument('inspections', data);
                }

                if (result.success) {
                    showMessageModal("Inspection document saved successfully!", "Success");
                    clearInspectionsForm();
                    showPage('inspectionsPage');
                    console.log("[Inspections] Operation successful. Form cleared and page re-shown.");
                } else {
                    console.error("[Inspections] Document operation failed:", result.error);
                }
            } catch (e) {
                console.error("[Inspections] Unhandled error during document operation:", e);
                showMessageModal("An unexpected error occurred during inspection document operation: " + e.message, "Operation Error");
            }
        }

        function clearInspectionsForm() {
            document.getElementById('inspectionForm').reset();
            document.getElementById('inspectionForm').removeAttribute('data-doc-id');
            document.getElementById('addUpdateButton').textContent = 'Add Document';
            // Explicitly clear the display field that now holds lifecycle status
            document.getElementById('revStatus').value = '';
            updateNextInsNumber();
            console.log("[Inspections] Form cleared.");
        }

        async function editInspection(docId) {
            showLoadingOverlay('Loading inspection data...');
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                showMessageModal("Application not fully loaded or Firebase not connected. Please wait and try again.", "Error");
                hideLoadingOverlay();
                return;
            }
            try {
                const docSnap = await getDoc(doc(db, `/artifacts/${appId}/users/${userId}/inspections`, docId));
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Populate date input fields with YYYY-MM-DD format
                    document.getElementById('date').value = formatDateForInput(data.date) || '';
                    document.getElementById('insNumber').value = data.insNumber || '';
                    document.getElementById('revision').value = data.revision || '';
                    document.getElementById('discipline').value = data.discipline || '';
                    document.getElementById('location').value = data.location || '';
                    // Removed submissionType from edit form
                    document.getElementById('workToBeInspected').value = data.workToBeInspected || '';
                    document.getElementById('inspectionDate').value = formatDateForInput(data.inspectionDate) || '';
                    document.getElementById('inspectionTime').value = data.inspectionTime || '';
                    document.getElementById('approvedDrawingRef').value = data.approvedDrawingRef || '';
                    document.getElementById('specificationRef').value = data.specificationRef || '';
                    document.getElementById('approvedMethodStatementRef').value = data.approvedMethodStatementRef || '';
                    document.getElementById('qcsReference').value = data.qcsReference || '';
                    document.getElementById('commentReceivedDate').value = formatDateForInput(data.commentReceivedDate) || '';
                    // Set the dropdown value
                    document.getElementById('documentStatus').value = data.documentStatus || '';
                    // Display the actual lifecycle status (Latest/Superseded) in the read-only field
                    document.getElementById('revStatus').value = data.revStatus || '';

                    document.getElementById('inspectionForm').dataset.docId = docId;
                    document.getElementById('addUpdateButton').textContent = 'Update Document';
                    window.scrollTo(0, 0);
                    console.log(`[Inspections] Data for ${docId} loaded into form for editing.`);
                } else {
                    console.error("No such inspection document!");
                    showMessageModal("Document not found for editing.", "Error");
                }
            } catch (error) {
                console.error("Error fetching inspection document for edit:", error);
                showMessageModal("Error loading document for editing: " + error.message, "Error");
            } finally {
                hideLoadingOverlay();
            }
        }

        // MIR Register
        async function addUpdateMirDocument() {
            console.log("[MIR] Starting addUpdateMirDocument...");
            const form = document.getElementById('mirForm');
            const docId = form.dataset.docId;
            const data = {
                mirDate: document.getElementById('mirDate').value,
                mirNumber: document.getElementById('mirNumber').value,
                mirRevision: document.getElementById('mirRevision').value,
                mirDiscipline: document.getElementById('mirDiscipline').value,
                dateMaterialReceived: document.getElementById('dateMaterialReceived').value,
                mirInspectionDate: document.getElementById('mirInspectionDate').value,
                mirInspectionTime: document.getElementById('mirInspectionTime').value,
                materialApprovalRef: document.getElementById('materialApprovalRef').value,
                descriptionMaterial: document.getElementById('descriptionMaterial').value,
                deliveryNoteNumber: document.getElementById('deliveryNoteNumber').value,
                manufacturer: document.getElementById('manufacturer').value,
                supplier: document.getElementById('supplier').value,
                countryOrigin: document.getElementById('countryOrigin').value,
                mirSubmissionDate: document.getElementById('mirSubmissionDate').value,
                mirResponseDate: document.getElementById('mirResponseDate').value,
                // These are the selected status from the dropdown
                mirApprovalStatus: document.getElementById('mirApprovalStatus').value,
                // This is the lifecycle status: 'Latest' or 'Superseded'
                mirRevStatus: '', // Will be determined by logic below
                // This is the approval text for display, not directly stored as 'mirRevStatus'
                mirApprovalSummaryStatus: getApprovalSummaryText(document.getElementById('mirApprovalStatus').value)
            };

            if (!data.mirDate || !data.mirNumber || !data.mirRevision || !data.mirDiscipline || !data.mirApprovalStatus) {
                showMessageModal("Please fill in all required fields: Date, MIR Number, Revision, Discipline, and Approval Status.", "Missing Information");
                console.warn("[MIR] Required fields missing. Operation aborted.");
                return;
            }
            try {
                let result;
                if (docId) {
                    // If editing an existing document, just update its content.
                    // Its lifecycle status ('Latest'/'Superseded') should not change here.
                    console.log(`[MIR] Updating existing document with ID: ${docId}`, data);
                    // Retain the existing mirRevStatus (lifecycle status)
                    const currentDoc = mirData.find(d => d.id === docId);
                    if (currentDoc) {
                        data.mirRevStatus = currentDoc.mirRevStatus;
                    }
                    result = await saveDocument('mir', docId, data);
                } else {
                    // Adding a new document or a new revision
                    console.log("[MIR] Adding new document or new revision:", data);

                    // Find any existing "Latest" MIR for this MIR Number and Discipline
                    const existingLatestMir = mirData.filter(d =>
                        d.mirNumber === data.mirNumber &&
                        d.mirDiscipline === data.mirDiscipline &&
                        d.mirRevStatus === 'Latest' // Only consider documents explicitly marked 'Latest'
                    );

                    let previousLatestDoc = null;
                    if (existingLatestMir.length > 0) {
                        // Sort by revision to ensure we get the absolute latest if multiple 'Latest' somehow exist
                        existingLatestMir.sort((a, b) => compareRevisions(a.mirRevision, b.mirRevision));
                        previousLatestDoc = existingLatestMir[existingLatestMir.length - 1];
                    }

                    if (previousLatestDoc && compareRevisions(data.mirRevision, previousLatestDoc.mirRevision) > 0) {
                        // If a previous 'Latest' exists and the new revision is indeed higher, supersede the old one.
                        console.log(`[MIR] Marking previous latest MIR (${previousLatestDoc.id}) as Superseded.`);
                        await saveDocument('mir', previousLatestDoc.id, { mirRevStatus: 'Superseded' });
                    } else if (previousLatestDoc && compareRevisions(data.mirRevision, previousLatestDoc.mirRevision) < 0) {
                        // Handle case where new revision is older than existing latest
                        showMessageModal("The revision you are adding is older than an existing 'Latest' revision for this MIR Number and Discipline. Please check the revision number.", "Warning: Older Revision");
                        data.mirRevStatus = 'Superseded'; // Treat older revisions as superseded by default
                    }

                    // The newly added document is always the new 'Latest' or the first document in its series.
                    data.mirRevStatus = 'Latest';

                    result = await addDocument('mir', data);
                }

                if (result.success) {
                    showMessageModal("MIR document saved successfully!", "Success");
                    clearMirForm();
                    showPage('mirPage');
                    console.log("[MIR] Operation successful. Form cleared and page re-shown.");
                } else {
                    console.error("[MIR] Document operation failed:", result.error);
                }
            } catch (e) {
                console.error("[MIR] Unhandled error during document operation:", e);
                showMessageModal("An unexpected error occurred during MIR document operation: " + e.message, "Operation Error");
            }
        }

        function clearMirForm() {
            document.getElementById('mirForm').reset();
            document.getElementById('mirForm').removeAttribute('data-doc-id');
            document.getElementById('addUpdateMirButton').textContent = 'Add Document';
            // Explicitly clear the display field that now holds lifecycle status
            document.getElementById('mirRevStatus').value = '';
            updateNextMirNumber();
            console.log("[MIR] Form cleared.");
        }

        async function editMir(docId) {
            showLoadingOverlay('Loading MIR data...');
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                showMessageModal("Application not fully loaded or Firebase not connected. Please wait and try again.", "Error");
                hideLoadingOverlay();
                return;
            }
            try {
                const docSnap = await getDoc(doc(db, `/artifacts/${appId}/users/${userId}/mir`, docId));
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Populate date input fields with YYYY-MM-DD format
                    document.getElementById('mirDate').value = formatDateForInput(data.mirDate) || '';
                    document.getElementById('mirNumber').value = data.mirNumber || '';
                    document.getElementById('mirRevision').value = data.mirRevision || '';
                    document.getElementById('mirDiscipline').value = data.mirDiscipline || '';
                    document.getElementById('dateMaterialReceived').value = formatDateForInput(data.dateMaterialReceived) || '';
                    document.getElementById('mirInspectionDate').value = formatDateForInput(data.mirInspectionDate) || '';
                    document.getElementById('mirInspectionTime').value = data.mirInspectionTime || '';
                    document.getElementById('materialApprovalRef').value = data.materialApprovalRef || '';
                    document.getElementById('descriptionMaterial').value = data.descriptionMaterial || '';
                    document.getElementById('deliveryNoteNumber').value = data.deliveryNoteNumber || '';
                    document.getElementById('manufacturer').value = data.manufacturer || '';
                    document.getElementById('supplier').value = data.supplier || '';
                    document.getElementById('countryOrigin').value = data.countryOrigin || '';
                    document.getElementById('mirSubmissionDate').value = formatDateForInput(data.mirSubmissionDate) || '';
                    document.getElementById('mirResponseDate').value = formatDateForInput(data.mirResponseDate) || '';
                    // Set the dropdown value
                    document.getElementById('mirApprovalStatus').value = data.mirApprovalStatus || '';
                    // Display the actual lifecycle status (Latest/Superseded) in the read-only field
                    document.getElementById('mirRevStatus').value = data.mirRevStatus || '';

                    document.getElementById('mirForm').dataset.docId = docId;
                    document.getElementById('addUpdateMirButton').textContent = 'Update Document';
                    window.scrollTo(0, 0);
                    console.log(`[MIR] Data for ${docId} loaded into form for editing.`);
                } else {
                    console.error("No such MIR document!");
                    showMessageModal("Document not found for editing.", "Error");
                }
            } catch (error) {
                console.error("Error fetching MIR document for edit:", error);
                showMessageModal("Error loading document for editing: " + error.message, "Error");
            } finally {
                hideLoadingOverlay();
            }
        }

        async function updateNextInsNumber() {
            if (typeof appId === 'undefined' || appId === 'default-app-id' || !db || !userId) {
                document.getElementById('nextInsNumber').textContent = 'Loading...';
                return;
            }
            const disciplineSelect = document.getElementById('discipline');
            const discipline = disciplineSelect ? disciplineSelect.value : '';
            if (discipline) {
                const nextNumber = await generateNextDocNumber('inspections', 'CP837-INS', 'insNumber', discipline);
                document.getElementById('nextInsNumber').textContent = nextNumber;
            } else {
                document.getElementById('nextInsNumber').textContent = 'Select Discipline';
            }
        }

        async function updateNextMirNumber() {
            if (typeof appId === 'undefined' || appId === 'default-app-id' || !db || !userId) {
                document.getElementById('nextMirNumber').textContent = 'Loading...';
                return;
            }
            const disciplineSelect = document.getElementById('mirDiscipline');
            const discipline = disciplineSelect ? disciplineSelect.value : '';
            if (discipline) {
                const nextNumber = await generateNextDocNumber('mir', 'CP837-MIR', 'mirNumber', discipline);
                document.getElementById('nextMirNumber').textContent = nextNumber;
            } else {
                document.getElementById('nextMirNumber').textContent = 'Select Discipline';
            }
        }

        // NCR Register - handleNcrFormSubmission already handles Latest/Superseded logic
        async function handleNcrFormSubmission() {
            console.log("[NCR] Starting handleNcrFormSubmission...");
            const form = document.getElementById('ncrForm');
            const docId = form.dataset.docId; // This will only be set if 'Edit' button was clicked

            const data = {
                ncrDiscipline: document.getElementById('ncrDiscipline').value,
                ncrRefNumber: document.getElementById('ncrRefNumber').value,
                ncrDescription: document.getElementById('ncrDescription').value,
                partAReceivedDate: document.getElementById('partAReceivedDate').value,

                ncrRev_PartB: document.getElementById('ncrRev_PartB').value,
                ncrRevisedParts_PartB: document.getElementById('ncrRevisedParts_PartB').value,
                immediateAction: document.getElementById('immediateAction').value,
                rootCause: document.getElementById('rootCause').value,
                correctiveAction: document.getElementById('correctiveAction').value,
                partBSubmittedDate: document.getElementById('partBSubmittedDate').value,

                partCReceivedDate: document.getElementById('partCReceivedDate').value,
                partBAcceptedByGEC: document.getElementById('partBAcceptedByGEC').value,
                ifPartBAccepted: document.getElementById('ifPartBAccepted').value,

                partDRev: document.getElementById('partDRev').value,
                partDRevisedParts: document.getElementById('partDRevisedParts').value,
                partDSubmittedDate: document.getElementById('partDSubmittedDate').value,

                partEReceivedDate: document.getElementById('partEReceivedDate').value,
                partEStatus: document.getElementById('partEStatus').value,
                ncrCurrentStatus: document.getElementById('ncrCurrentStatus').value,
            };

            if (!data.ncrDiscipline || !data.ncrRefNumber || (data.ncrRev_PartB === null || data.ncrRev_PartB === undefined || data.ncrRev_PartB === '')) {
                showMessageModal("Please fill in required fields: Discipline, NCR Ref. Number, and Part B Revision.", "Missing Information");
                console.warn("[NCR] Required fields missing. Operation aborted.");
                return;
            }

            try {
                let result;
                if (docId) { // If docId is present, it means we are editing an EXISTING specific row
                    console.log(`[NCR] Updating existing NCR document with ID: ${docId}`, data);
                    result = await saveDocument('ncr', docId, data);
                    if (result.success) {
                        showMessageModal("NCR document updated successfully!", "Success");
                    }
                } else { // This is a new record, either brand new NCR or new revision for an existing NCR Ref.
                    // Find if there's an existing "Latest" NCR for this Ref Number and Discipline
                    const existingLatestNCRS = ncrData.filter(d =>
                        d.ncrRefNumber === data.ncrRefNumber &&
                        d.ncrDiscipline === data.ncrDiscipline &&
                        d.ncrLifecycleStatus === 'Latest'
                    );

                    // If there's an existing 'Latest' NCR, mark it as 'Superseded'
                    if (existingLatestNCRS.length > 0) {
                        // Sort to ensure we get the absolute latest if multiple somehow exists (shouldn't happen with correct logic)
                        existingLatestNCRS.sort((a, b) => compareRevisions(a.ncrRev_PartB, b.ncrRev_PartB));
                        const previousLatestNcr = existingLatestNCRS[existingLatestNCRS.length - 1];

                        console.log(`[NCR] Marking previous latest NCR (${previousLatestNcr.id}) as Superseded.`);
                        await saveDocument('ncr', previousLatestNcr.id, { ncrLifecycleStatus: 'Superseded' });
                    }

                    // Add the new NCR/revision as a new document and mark it as 'Latest'
                    data.ncrLifecycleStatus = 'Latest'; // The newly added document is always the latest of its series
                    if (!data.ncrRev_PartB) { // Ensure Part B Rev is '0' for the very first entry if not explicitly set
                        data.ncrRev_PartB = '0';
                    }
                    console.log("[NCR] Adding new NCR (or revision) document:", data);
                    result = await addDocument('ncr', data);
                    if (result.success) {
                        showMessageModal("New NCR (or revision) added successfully!", "Success");
                    }
                }

                if (result.success) {
                    clearNcrForm();
                    showPage('ncrPage'); // Ensure we are on the NCR page
                    console.log("[NCR] Operation successful. Form cleared and page re-shown.");
                } else {
                    console.error("[NCR] Document operation failed:", result.error);
                }
            } catch (e) {
                console.error("[NCR] Unhandled error during document operation:", e);
                showMessageModal("An unexpected error occurred during NCR document operation: " + e.message, "Operation Error");
            }
        }

        function clearNcrForm() {
            const form = document.getElementById('ncrForm');
            form.reset();
            form.removeAttribute('data-doc-id'); // Clear docId for new entry/new revision
            document.getElementById('addUpdateNcrButton').textContent = 'Add Document'; // Reset button text
            document.getElementById('ifPartBAccepted').value = ''; // Clear derived field
            document.getElementById('ncrRev_PartB').value = '0'; // Default new Part B Rev to 0
            // Clear Part D fields explicitly
            document.getElementById('partDRev').value = '';
            document.getElementById('partDRevisedParts').value = '';
            console.log("[NCR] Form cleared.");
        }

        /**
         * Fills the NCR form with data from a given NCR document.
         * @param {Object} data The NCR document data.
         * @param {string|null} docId The document ID if editing a specific row. If null, it's a new entry/revision.
         * @param {boolean} forNewRevision If true, it means we are preparing the form to add a *new revision* based on `data`.
         */
        function fillNcrForm(data, docId = null, forNewRevision = false) {
            // Part A fields - always populate from provided data
            // Assuming these are <input type="date"> fields, which expect YYYY-MM-DD format
            document.getElementById('ncrDiscipline').value = data.ncrDiscipline || '';
            document.getElementById('ncrRefNumber').value = data.ncrRefNumber || '';
            document.getElementById('ncrDescription').value = data.ncrDescription || '';
            document.getElementById('partAReceivedDate').value = formatDateForInput(data.partAReceivedDate) || '';

            // Part B fields logic
            if (forNewRevision) {
                document.getElementById('ncrRev_PartB').value = getNextRevision(data.ncrRev_PartB || '0');
                document.getElementById('ncrRevisedParts_PartB').value = ''; // Clear for new input
                document.getElementById('immediateAction').value = ''; // Clear for new input
                document.getElementById('rootCause').value = '';    // Clear for new input
                document.getElementById('correctiveAction').value = ''; // Clear for new input
                document.getElementById('partBSubmittedDate').value = ''; // Clear for new input
            } else {
                // If not for new revision (i.e., for direct edit), fill from data
                document.getElementById('ncrRev_PartB').value = data.ncrRev_PartB || '';
                document.getElementById('ncrRevisedParts_PartB').value = data.ncrRevisedParts_PartB || '';
                document.getElementById('immediateAction').value = data.immediateAction || '';
                document.getElementById('rootCause').value = data.rootCause || '';
                document.getElementById('correctiveAction').value = data.correctiveAction || '';
                document.getElementById('partBSubmittedDate').value = formatDateForInput(data.partBSubmittedDate) || '';
            }

            // Part C fields - always populate from provided data (for display/reference if it exists)
            // Assuming these are <input type="date"> fields, which expect YYYY-MM-DD format
            document.getElementById('partCReceivedDate').value = formatDateForInput(data.partCReceivedDate) || '';
            document.getElementById('partBAcceptedByGEC').value = data.partBAcceptedByGEC || '';

            // Part D and E fields - always clear if creating new revision, otherwise fill from data
            if (forNewRevision) {
                document.getElementById('partDRev').value = '';
                document.getElementById('partDRevisedParts').value = '';
                document.getElementById('partDSubmittedDate').value = ''; // Should be YYYY-MM-DD
                document.getElementById('partEReceivedDate').value = ''; // Should be YYYY-MM-DD
                document.getElementById('partEStatus').value = '';
                document.getElementById('ncrCurrentStatus').value = '';
            } else {
                document.getElementById('partDRev').value = data.partDRev || '';
                document.getElementById('partDRevisedParts').value = data.partDRevisedParts || '';
                document.getElementById('partDSubmittedDate').value = formatDateForInput(data.partDSubmittedDate) || ''; // Should be YYYY-MM-DD
                document.getElementById('partEReceivedDate').value = formatDateForInput(data.partEReceivedDate) || ''; // Should be YYYY-MM-DD
                document.getElementById('partEStatus').value = data.partEStatus || '';
                document.getElementById('ncrCurrentStatus').value = data.ncrCurrentStatus || '';
            }


            // Set docId and button text based on whether it's a direct edit
            const formElement = document.getElementById('ncrForm');
            const addButton = document.getElementById('addUpdateNcrButton');

            if (docId) { // Direct edit of an existing record
                formElement.dataset.docId = docId;
                addButton.textContent = 'Update Document';
            } else { // New entry or new revision
                formElement.removeAttribute('data-doc-id');
                addButton.textContent = 'Add Document';
            }

            // Trigger change event for derived fields (like ifPartBAccepted)
            document.getElementById('partBAcceptedByGEC').dispatchEvent(new Event('change'));

            window.scrollTo(0, 0); // Scroll to top of form
            console.log(`[NCR] Form filled for ${docId ? 'editing' : 'new revision'}.`);
        }

        async function editNcr(docId) {
            showLoadingOverlay('Loading NCR data...');
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                showMessageModal("Application not fully loaded or Firebase not connected. Please wait and try again.", "Error");
                hideLoadingOverlay();
                return;
            }
            try {
                const docSnap = await getDoc(doc(db, `/artifacts/${appId}/users/${userId}/ncr`, docId));
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Populate the form for DIRECT EDIT of this specific document
                    fillNcrForm(data, docSnap.id, false); // Pass false for forNewRevision
                    console.log(`[NCR] Data for ${docId} loaded into form for editing.`);
                } else {
                    console.error("No such NCR document!");
                    showMessageModal("Document not found for editing.", "Error");
                }
            } catch (error) {
                console.error("Error fetching NCR document for edit:", error);
                showMessageModal("Error loading document for editing: " + error.message, "Error");
            } finally {
                hideLoadingOverlay();
            }
        }

        // Submission Register
        async function addNewSubmissionDocument() {
            console.log("[Submission] Starting addNewSubmissionDocument...");
            const form = document.getElementById('submissionForm');
            const docId = form.dataset.docId; // Will be defined if editing an existing record

            const data = {
                docNumber: document.getElementById('newDocNumber').value,
                rev: document.getElementById('newRev').value,
                discipline: document.getElementById('newDiscipline').value,
                docType: document.getElementById('newDocType').value,
                section: document.getElementById('newSection').value,
                docTitle: document.getElementById('newDocTitle').value,
                subRef: document.getElementById('newSubRef').value,
                submittedDate: document.getElementById('newSubmittedDate').value,
                respondedDate: document.getElementById('newRespondedDate').value,
                // GEC Due Date is calculated and stored as YYYY-MM-DD
                gecDueDate: document.getElementById('newSubmittedDate').value ? new Date(new Date(document.getElementById('newSubmittedDate').value).setDate(new Date(document.getElementById('newSubmittedDate').value).getDate() + 14)).toISOString().split('T')[0] : '',
                status: document.getElementById('newStatus').value, // This is the approval status (A,B,C,UR etc)
                verifyRev: 'Latest', // Default to Latest for new submissions, will be adjusted below
                daysOverdue: calculateDaysOverdue(document.getElementById('newSubmittedDate').value, document.getElementById('newRespondedDate').value),
            };

            // Basic validation
            if (!data.docNumber || !data.rev || !data.discipline || !data.docType || !data.docTitle || !data.submittedDate) {
                showMessageModal("Please fill in all required fields for Submission: Document Number, Revision, Discipline, Document Type, Document Title, Submitted Date.", "Missing Information");
                console.warn("[Submission] Required fields missing. Operation aborted.");
                return;
            }

            console.log("[Submission] Attempting to add/update document. docId:", docId, "Data:", JSON.stringify(data));

            try {
                let result;
                if (docId) { // This branch is for editing an existing row (not adding a new revision)
                    console.log(`[Submission] Updating existing document with ID: ${docId}. Its lifecycle status will be preserved.`);
                    // When editing an existing document, we preserve its current lifecycle status.
                    const existingDoc = submissionData.find(d => d.id === docId);
                    if (existingDoc) {
                        data.verifyRev = existingDoc.verifyRev; // Retain current lifecycle status (Latest/Superseded)
                    }
                    result = await saveDocument('submissions', docId, data);
                    if (result.success) {
                        showMessageModal("Submission document updated successfully!", "Success");
                        clearNewSubmissionDocumentForm(); // Clear form after successful update
                        showPage('submissionPage'); // Ensure we are on the submission page
                        console.log("[Submission] Update operation successful.");
                    } else {
                        console.error("[Submission] Document update failed:", result.error);
                    }
                } else { // This branch is for adding a new document (which might be a new revision)
                    console.log("[Submission] Adding new document or new revision.");

                    // LOGGING: Current state of submissionData before filtering
                    console.log("[Submission Debug] Current submissionData before filter:", JSON.stringify(submissionData.map(d => ({id: d.id, docNumber: d.docNumber, rev: d.rev, verifyRev: d.verifyRev}))));


                    // Find any existing "Latest" submission for this Document Number and Discipline
                    // A document is considered "Latest" if its verifyRev is NOT 'Superseded'
                    const existingLatestCandidates = submissionData.filter(d =>
                        d.docNumber === data.docNumber &&
                        d.discipline === data.discipline &&
                        (d.verifyRev !== 'Superseded' && d.verifyRev !== 'superseded') // Case-insensitive check for 'Superseded'
                    );
                    console.log("[Submission Debug] Found existingLatestCandidates (before sorting, i.e., not 'Superseded'):", JSON.stringify(existingLatestCandidates.map(d => ({id: d.id, rev: d.rev, verifyRev: d.verifyRev}))));

                    let previousLatestDoc = null;
                    if (existingLatestCandidates.length > 0) {
                        // Sort by revision to ensure we get the highest revision among the candidates.
                        existingLatestCandidates.sort((a, b) => compareRevisions(a.rev, b.rev));
                        previousLatestDoc = existingLatestCandidates[existingLatestCandidates.length - 1];
                        console.log("[Submission Debug] Identified previousLatestDoc based on candidates:", JSON.stringify({id: previousLatestDoc.id, rev: previousLatestDoc.rev, verifyRev: previousLatestDoc.verifyRev}));
                    }

                    if (previousLatestDoc) {
                        const comparisonResult = compareRevisions(data.rev, previousLatestDoc.rev);
                        console.log(`[Submission Debug] Comparing new revision (${data.rev}) with previous latest (${previousLatestDoc.rev}). Comparison Result: ${comparisonResult}`);

                        if (comparisonResult > 0) {
                            // New revision is genuinely higher, so supersede the old one.
                            console.log(`[Submission Debug] New revision (${data.rev}) is higher than previous latest (${previousLatestDoc.rev}). Marking previous latest (${previousLatestDoc.id}) as Superseded.`);
                            const supersedeResult = await saveDocument('submissions', previousLatestDoc.id, { verifyRev: 'Superseded' });
                            if (!supersedeResult.success) {
                                showMessageModal("Failed to mark previous document as superseded. Data inconsistency may occur.", "Supersede Error");
                                console.error("[Submission Debug] Supersede operation failed:", supersedeResult.error);
                            } else {
                                console.log(`[Submission Debug] Previous document ${previousLatestDoc.id} successfully superseded.`);
                            }
                            data.verifyRev = 'Latest'; // The new document is now the latest
                        } else if (comparisonResult < 0) {
                            // New revision is older, so it should be automatically superseded.
                            showMessageModal("The revision you are adding is older than an existing 'Latest' revision for this Document Number and Discipline. It will be added as 'Superseded'.", "Warning: Older Revision");
                            data.verifyRev = 'Superseded';
                            console.log("[Submission Debug] New revision is older. Marking new document as Superseded.");
                        } else { // comparisonResult === 0 (exact same revision and doc number)
                            // This scenario implies a re-submission of the exact same revision.
                            // It's safer to treat this new submission as superseded, or block it.
                            showMessageModal("A document with the exact same Document Number, Discipline, and Revision already exists and is not 'Superseded'. This new entry will be added as 'Superseded'. If you intended to edit, please use the 'Edit' button for the existing document.", "Warning: Duplicate Revision");
                            data.verifyRev = 'Superseded';
                            console.log("[Submission Debug] Exact duplicate of existing 'Latest' revision detected. Marking new document as Superseded.");
                        }
                    } else {
                        // No previous 'Latest' document found for this docNumber and discipline (meaning no current document is NOT 'Superseded'), so this is the first 'Latest'.
                        console.log("[Submission Debug] No non-superseded document found for this Doc Number and Discipline. This new document will be 'Latest'.");
                        data.verifyRev = 'Latest'; // It's the first in its series, so it's latest.
                    }

                    // Finally, add the new document (which already has its verifyRev set)
                    console.log("[Submission Debug] Adding new document with final data:", JSON.stringify(data));
                    result = await addDocument('submissions', data);
                    if (result.success) {
                        showMessageModal("New submission document added successfully!", "Success");
                        clearNewSubmissionDocumentForm(); // Clear form after adding
                        showPage('submissionPage'); // Ensure we are on the submission page
                        console.log("[Submission] Add operation successful.");
                    } else {
                        console.error("[Submission] Document add failed:", result.error);
                    }
                }
            } catch (e) {
                console.error("[Submission] Unhandled error during document operation:", e);
                showMessageModal("An unexpected error occurred during submission document operation: " + e.message, "Operation Error");
            }
        }

        function clearNewSubmissionDocumentForm() {
            const form = document.getElementById('submissionForm');
            form.reset();
            form.removeAttribute('data-doc-id');
            document.querySelector('#submissionForm button.action-button').textContent = 'Add Document';
            // Clear the read-only lifecycle status field
            document.getElementById('lifecycleStatus').value = '';
            document.getElementById('daysOverdue').value = ''; // Also clear days overdue
            document.getElementById('gecDueDate').value = ''; // Clear GEC Due Date
            console.log("[Submission] Form cleared.");
        }

        async function editSubmission(docId) {
            showLoadingOverlay('Loading submission data...');
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                showMessageModal("Application not fully loaded or Firebase not connected. Please wait and try again.", "Error");
                hideLoadingOverlay();
                return;
            }
            try {
                const docSnap = await getDoc(doc(db, `/artifacts/${appId}/users/${userId}/submissions`, docId));
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Populate date input fields with YYYY-MM-DD format
                    document.getElementById('newDocNumber').value = data.docNumber || '';
                    document.getElementById('newRev').value = data.rev || '';
                    document.getElementById('newDiscipline').value = data.discipline || '';
                    document.getElementById('newDocType').value = data.docType || '';
                    document.getElementById('newSection').value = data.section || '';
                    document.getElementById('newDocTitle').value = data.docTitle || '';
                    document.getElementById('newSubRef').value = data.subRef || '';
                    document.getElementById('newSubmittedDate').value = formatDateForInput(data.submittedDate) || '';
                    document.getElementById('newRespondedDate').value = formatDateForInput(data.respondedDate) || '';
                    document.getElementById('newStatus').value = data.status || '';
                    document.getElementById('lifecycleStatus').value = data.verifyRev || ''; // Populate the read-only field
                    document.getElementById('daysOverdue').value = data.daysOverdue || ''; // Populate days overdue
                    // Format GEC Due Date for display in the read-only field
                    document.getElementById('gecDueDate').value = formatDateForInput(data.gecDueDate) || '';

                    const form = document.getElementById('submissionForm');
                    form.dataset.docId = docId;
                    document.querySelector('#submissionForm button.action-button').textContent = 'Update Document';
                    window.scrollTo(0, 0);
                    console.log(`[Submission] Data for ${docId} loaded into form for editing.`);
                } else {
                    console.error("No such submission document!");
                    showMessageModal("Document not found for editing.", "Error");
                }
            } catch (error) {
                console.error("Error fetching submission document for edit:", error);
                showMessageModal("Error loading document for editing: " + error.message, "Error");
            } finally {
                hideLoadingOverlay();
            }
        }

        // Correspondence Register - Outgoing
        async function addNewOutgoingCorrespondence() {
            console.log("[Outgoing Correspondence] Starting addNewOutgoingCorrespondence...");
            // Get the form using its new ID
            const form = document.getElementById('outgoingCorrespondenceForm');
            const docId = form.dataset.docId;

            const data = {
                initiator: document.getElementById('newOutgoingInitiator').value,
                addressee: document.getElementById('newOutgoingAddressee').value,
                letterRef: document.getElementById('newOutgoingLetterRef').value,
                // Values from date input fields are already YYYY-MM-DD
                letterDate: document.getElementById('newOutgoingLetterDate').value,
                letterSubject: document.getElementById('newOutgoingLetterSubject').value,
                inReplyToRef: document.getElementById('newOutgoingInReplyToRef').value,
                keyword: document.getElementById('newOutgoingKeyword').value,
                replyRequired: document.getElementById('newOutgoingReplyRequired').value,
                dateSent: document.getElementById('newOutgoingDateSent').value,
                status: document.getElementById('newOutgoingReplyRequired').value === 'Yes' ? 'OPEN' : 'CLOSED'
            };

            if (!data.letterRef || !data.letterSubject || !data.replyRequired) {
                showMessageModal("Please fill in all required fields for Outgoing Correspondence: Outgoing Letter Ref., Letter Subject, Reply Required.", "Missing Information");
                console.warn("[Outgoing Correspondence] Required fields missing. Operation aborted.");
                return;
            }
            console.log("[Outgoing Correspondence] Attempting to add/update document. docId:", docId, "Data:", data);

            try {
                let result;
                if (docId) {
                    result = await saveDocument('outgoing_correspondences', docId, data);
                } else {
                    result = await addDocument('outgoing_correspondences', data);
                }

                if (result.success) {
                    showMessageModal("Outgoing correspondence saved successfully!", "Success");
                    clearNewOutgoingCorrespondenceForm();
                    showPage('correspondencePage'); // Ensure we are on the correspondence page
                    console.log("[Outgoing Correspondence] Operation successful. Form cleared and page re-shown.");
                } else {
                    console.error("[Outgoing Correspondence] Document operation failed:", result.error);
                }
            }
            catch (e) {
                console.error("[Outgoing Correspondence] Unhandled error during document operation:", e);
                showMessageModal("An unexpected error occurred during outgoing correspondence document operation: " + e.message, "Operation Error");
            }
        }

        function clearNewOutgoingCorrespondenceForm() {
            // Use the new form ID
            const form = document.getElementById('outgoingCorrespondenceForm');
            form.reset();
            form.removeAttribute('data-doc-id');
            // Target the button directly using its form ID and a class
            document.querySelector('#outgoingCorrespondenceForm button.action-button').textContent = 'Add Outgoing';
            console.log("[Outgoing Correspondence] Form cleared.");
        }

        async function editOutgoing(docId) {
            showLoadingOverlay('Loading outgoing correspondence data...');
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                showMessageModal("Application not fully loaded or Firebase not connected. Please wait and try again.", "Error");
                hideLoadingOverlay();
                return;
            }
            try {
                const docSnap = await getDoc(doc(db, `/artifacts/${appId}/users/${userId}/outgoing_correspondences`, docId));
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Populate date input fields with YYYY-MM-DD format
                    document.getElementById('newOutgoingInitiator').value = data.initiator || '';
                    document.getElementById('newOutgoingAddressee').value = data.addressee || '';
                    document.getElementById('newOutgoingLetterRef').value = data.letterRef || '';
                    document.getElementById('newOutgoingLetterDate').value = formatDateForInput(data.letterDate) || '';
                    document.getElementById('newOutgoingLetterSubject').value = data.letterSubject || '';
                    document.getElementById('newOutgoingInReplyToRef').value = data.inReplyToRef || '';
                    document.getElementById('newOutgoingKeyword').value = data.keyword || '';
                    document.getElementById('newOutgoingReplyRequired').value = data.replyRequired || '';
                    document.getElementById('newOutgoingDateSent').value = formatDateForInput(data.dateSent) || '';

                    // Use the new form ID
                    const form = document.getElementById('outgoingCorrespondenceForm');
                    form.dataset.docId = docId;
                    document.querySelector('#outgoingCorrespondenceForm button.action-button').textContent = 'Update Outgoing';
                    window.scrollTo(0, 0);
                    console.log(`[Outgoing Correspondence] Data for ${docId} loaded into form for editing.`);
                } else {
                    console.error("No such outgoing correspondence document!");
                    showMessageModal("Document not found for editing.", "Error");
                }
            } catch (error) {
                console.error("Error fetching outgoing correspondence document for edit:", error);
                showMessageModal("Error loading document for editing: " + error.message, "Error");
            } finally {
                hideLoadingOverlay();
            }
        }

        // Correspondence Register - Incoming
        async function addNewIncomingCorrespondence() {
            console.log("[Incoming Correspondence] Starting addNewIncomingCorrespondence...");
            // Get the form using its new ID
            const form = document.getElementById('incomingCorrespondenceForm');
            const docId = form.dataset.docId;

            const data = {
                incomingRef: document.getElementById('newIncomingRef').value,
                // Values from date input fields are already YYYY-MM-DD
                dateOfReceipt: document.getElementById('newIncomingDateOfReceipt').value,
                originator: document.getElementById('newIncomingOriginator').value,
                addressee: document.getElementById('newIncomingAddressee').value,
                letterSubject: document.getElementById('newIncomingLetterSubject').value,
                replyToRef: document.getElementById('newIncomingReplyToRef').value,
                keyword: document.getElementById('newIncomingKeyword').value,
                replyRequired: document.getElementById('newIncomingReplyRequired').value,
                status: document.getElementById('newIncomingReplyRequired').value === 'Yes' ? 'OPEN' : 'CLOSED'
            };

            if (!data.incomingRef || !data.letterSubject || !data.replyRequired) {
                showMessageModal("Please fill in all required fields for Incoming Correspondence: Incoming Reference, Letter Subject, Reply Required.", "Missing Information");
                console.warn("[Incoming Correspondence] Required fields missing. Operation aborted.");
                return;
            }
            console.log("[Incoming Correspondence] Attempting to add/update document. docId:", docId, "Data:", data);

            try {
                let result;
                if (docId) {
                    result = await saveDocument('incoming_correspondences', docId, data);
                } else {
                    result = await addDocument('incoming_correspondences', data);
                }

                if (result.success) {
                    showMessageModal("Incoming correspondence saved successfully!", "Success");
                    clearNewIncomingCorrespondenceForm();
                    showPage('correspondencePage'); // Ensure we are on the correspondence page
                    console.log("[Incoming Correspondence] Operation successful. Form cleared and page re-shown.");
                } else {
                    console.error("[Incoming Correspondence] Document operation failed:", result.error);
                }
            } catch (e) {
                console.error("[Incoming Correspondence] Unhandled error during document operation:", e);
                showMessageModal("An unexpected error occurred during incoming correspondence document operation: " + e.message, "Operation Error");
            }
        }

        function clearNewIncomingCorrespondenceForm() {
            // Use the new form ID
            const form = document.getElementById('incomingCorrespondenceForm');
            form.reset();
            form.removeAttribute('data-doc-id');
            // Target the button directly using its form ID and a class
            document.querySelector('#incomingCorrespondenceForm button.action-button').textContent = 'Add Incoming';
            console.log("[Incoming Correspondence] Form cleared.");
        }

        async function editIncoming(docId) {
            showLoadingOverlay('Loading incoming correspondence data...');
            if (!db || !userId || typeof appId === 'undefined' || appId === 'default-app-id') {
                showMessageModal("Application not fully loaded or Firebase not connected. Please wait and try again.", "Error");
                hideLoadingOverlay();
                return;
            }
            try {
                const docSnap = await getDoc(doc(db, `/artifacts/${appId}/users/${userId}/incoming_correspondences`, docId));
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Populate date input fields with YYYY-MM-DD format
                    document.getElementById('newIncomingRef').value = data.incomingRef || '';
                    document.getElementById('newIncomingDateOfReceipt').value = formatDateForInput(data.dateOfReceipt) || '';
                    document.getElementById('newIncomingOriginator').value = data.originator || '';
                    document.getElementById('newIncomingAddressee').value = data.addressee || '';
                    document.getElementById('newIncomingLetterSubject').value = data.letterSubject || '';
                    document.getElementById('newIncomingReplyToRef').value = data.replyToRef || '';
                    document.getElementById('newIncomingKeyword').value = data.keyword || '';
                    document.getElementById('newIncomingReplyRequired').value = data.replyRequired || '';

                    // Use the new form ID
                    const form = document.getElementById('incomingCorrespondenceForm');
                    form.dataset.docId = docId;
                    document.querySelector('#incomingCorrespondenceForm button.action-button').textContent = 'Update Incoming';
                    window.scrollTo(0, 0);
                    console.log(`[Incoming Correspondence] Data for ${docId} loaded into form for editing.`);
                } else {
                    console.error("No such incoming correspondence document!");
                    showMessageModal("Document not found for editing.", "Error");
                }
            } catch (error) {
                console.error("Error fetching incoming correspondence document for edit:", error);
                showMessageModal("Error loading document for editing: " + error.message, "Error");
            } finally {
                hideLoadingOverlay();
            }
        }


        // --- Render Table Rows ---

        function renderInspectionRow(doc, collectionName) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${formatDateForDisplay(doc.date)}</td>
                <td>${doc.discipline || ''}</td>
                <td>${doc.insNumber || ''}</td>
                <td>${doc.revision || ''}</td>
                <td>${doc.location || ''}</td>
                <!-- Removed Submission Type from row rendering -->
                <td>${doc.workToBeInspected || ''}</td>
                <td>${formatDateForDisplay(doc.inspectionDate)}</td>
                <td>${doc.inspectionTime || ''}</td>
                <td>${doc.approvedDrawingRef || ''}</td>
                <td>${doc.specificationRef || ''}</td>
                <td>${doc.approvedMethodStatementRef || ''}</td>
                <td>${doc.qcsReference || ''}</td>
                <td>${formatDateForDisplay(doc.commentReceivedDate)}</td>
                <td>${doc.documentStatus || ''}</td>
                <td>${doc.revStatus || ''}</td> <!-- This now displays 'Latest' or 'Superseded' -->
                <td class="action-buttons">
                    <button class="edit-button" onclick="editInspection('${doc.id}')">Edit</button>
                    <button class="delete-button" onclick="deleteDocument('inspections', '${doc.id}')">Delete</button>
                </td>
            `;
            return tr;
        }

        function renderMirRow(doc, collectionName) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${formatDateForDisplay(doc.mirDate)}</td>
                <td>${doc.mirDiscipline || ''}</td>
                <td>${doc.mirNumber || ''}</td>
                <td>${doc.mirRevision || ''}</td>
                <td>${formatDateForDisplay(doc.dateMaterialReceived)}</td>
                <td>${formatDateForDisplay(doc.mirInspectionDate)}</td>
                <td>${doc.mirInspectionTime || ''}</td>
                <td>${doc.materialApprovalRef || ''}</td>
                <td>${doc.descriptionMaterial || ''}</td>
                <td>${doc.deliveryNoteNumber || ''}</td>
                <td>${doc.manufacturer || ''}</td>
                <td>${doc.supplier || ''}</td>
                <td>${doc.countryOrigin || ''}</td>
                <td>${formatDateForDisplay(doc.mirSubmissionDate)}</td>
                <td>${formatDateForDisplay(doc.mirResponseDate)}</td>
                <td>${doc.mirApprovalStatus || ''}</td>
                <td>${doc.mirRevStatus || ''}</td> <!-- This now displays 'Latest' or 'Superseded' -->
                <td class="action-buttons">
                    <button class="edit-button" onclick="editMir('${doc.id}')">Edit</button>
                    <button class="delete-button" onclick="deleteDocument('mir', '${doc.id}')">Delete</button>
                </td>
            `;
            return tr;
        }

        function renderNcrRow(doc, collectionName) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${doc.ncrRefNumber || ''}</td>
                <td>${doc.ncrDiscipline || ''}</td>
                <td>${doc.ncrLifecycleStatus || ''}</td>
                <td>${doc.ncrDescription || ''}</td>
                <td>${formatDateForDisplay(doc.partAReceivedDate)}</td>
                <td>${doc.ncrRev_PartB || ''}</td>
                <td>${doc.ncrRevisedParts_PartB || ''}</td>
                <td>${doc.immediateAction || ''}</td>
                <td>${doc.rootCause || ''}</td>
                <td>${doc.correctiveAction || ''}</td>
                <td>${formatDateForDisplay(doc.partBSubmittedDate)}</td>
                <td>${formatDateForDisplay(doc.partCReceivedDate)}</td>
                <td>${doc.partBAcceptedByGEC || ''}</td>
                <td>${doc.ifPartBAccepted || ''}</td>
                <td>${doc.partDRev || ''}</td>
                <td>${doc.partDRevisedParts || ''}</td>
                <td>${formatDateForDisplay(doc.partDSubmittedDate)}</td>
                <td>${formatDateForDisplay(doc.partEReceivedDate)}</td>
                <td>${doc.partEStatus || ''}</td>
                <td>${doc.ncrCurrentStatus || ''}</td>
                <td class="action-buttons">
                    <button class="edit-button" onclick="editNcr('${doc.id}')">Edit</button>
                    <button class="delete-button" onclick="deleteDocument('ncr', '${doc.id}')">Delete</button>
                </td>
            `;
            return tr;
        }

        function renderSubmissionRow(doc, collectionName) {
            const tr = document.createElement('tr');

            // Extract just "Latest" or "Superseded" from doc.verifyRev for display
            let lifecycleStatusForDisplay = '';
            if (doc.verifyRev) {
                // This regex captures "Latest" or "Superseded" from the beginning of the string
                const match = doc.verifyRev.match(/^(Latest|Superseded)/i);
                if (match) {
                    lifecycleStatusForDisplay = match[0];
                } else {
                    // Fallback if it's neither "Latest" nor "Superseded" for some reason
                    lifecycleStatusForDisplay = doc.verifyRev;
                }
            }

            tr.innerHTML = `
                <td>${doc.docNumber || ''}</td>
                <td>${doc.rev || ''}</td>
                <td>${doc.discipline || ''}</td>
                <td>${doc.docType || ''}</td>
                <td>${doc.section || ''}</td>
                <td>${doc.docTitle || ''}</td>
                <td>${doc.subRef || ''}</td>
                <td>${formatDateForDisplay(doc.submittedDate)}</td>
                <td>${formatDateForDisplay(doc.gecDueDate)}</td>
                <td>${formatDateForDisplay(doc.respondedDate)}</td>
                <td>${doc.status || ''}</td>
                <td>${lifecycleStatusForDisplay}</td> <!-- This line is changed -->
                <td>${doc.daysOverdue || ''}</td>
                <td class="action-buttons">
                    <button class="edit-button" onclick="editSubmission('${doc.id}')">Edit</button>
                    <button class="delete-button" onclick="deleteDocument('submissions', '${doc.id}')">Delete</button>
                </td>
            `;
            return tr;
        }

        function renderOutgoingCorrespondenceRow(doc, collectionName) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${doc.initiator || ''}</td>
                <td>${doc.addressee || ''}</td>
                <td>${doc.letterRef || ''}</td>
                <td>${formatDateForDisplay(doc.letterDate)}</td>
                <td>${doc.letterSubject || ''}</td>
                <td>${doc.inReplyToRef || ''}</td>
                <td>${doc.keyword || ''}</td>
                <td>${doc.replyRequired || ''}</td>
                <td>${formatDateForDisplay(doc.dateSent)}</td>
                <td>${doc.status || ''}</td>
                <td class="action-buttons">
                    <button class="edit-button" onclick="editOutgoing('${doc.id}')">Edit</button>
                    <button class="delete-button" onclick="deleteDocument('outgoing_correspondences', '${doc.id}')">Delete</button>
                </td>
            `;
            return tr;
        }

        function renderIncomingCorrespondenceRow(doc, collectionName) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${doc.incomingRef || ''}</td>
                <td>${formatDateForDisplay(doc.dateOfReceipt)}</td>
                <td>${doc.originator || ''}</td>
                <td>${doc.addressee || ''}</td>
                <td>${doc.letterSubject || ''}</td>
                <td>${doc.replyToRef || ''}</td>
                <td>${doc.keyword || ''}</td>
                <td>${doc.replyRequired || ''}</td>
                <td>${doc.status || ''}</td>
                <td class="action-buttons">
                    <button class="edit-button" onclick="editIncoming('${doc.id}')">Edit</button>
                    <button class="delete-button" onclick="deleteDocument('incoming_correspondences', '${doc.id}')">Delete</button>
                </td>
            `;
            return tr;
        }


        // --- Search and Filter Functions (client-side for simplicity) ---
        function performInspectionsSearch() {
            const tableBody = document.querySelector('#inspectionsTable tbody');
            tableBody.innerHTML = '';
            const field = document.getElementById('inspectionsSearchField').value;
            const term = document.getElementById('inspectionsSearchTerm').value.toLowerCase();
            let filtered = inspectionsData.filter(doc => {
                if (!term) return true;
                // Check against lifecycle status if the field is 'revStatus'
                if (field === 'revStatus' && doc.revStatus) {
                    return String(doc.revStatus).toLowerCase().includes(term);
                } else if (field && doc[field]) {
                    // Apply date formatting for comparison if it's a date field
                    if (field.toLowerCase().includes('date')) {
                        return formatDateForDisplay(doc[field]).toLowerCase().includes(term);
                    }
                    return String(doc[field]).toLowerCase().includes(term);
                }
                // Fallback for general search across all string values, format dates for comparison
                return Object.values(doc).some(value => {
                    if (typeof value === 'string' && value.toLowerCase().includes('date')) { // Heuristic for date fields
                        return formatDateForDisplay(value || '').toLowerCase().includes(term);
                    }
                    return String(value || '').toLowerCase().includes(term);
                });
            });

            // Sort by date (ascending) then INS Number (ascending) then Revision (ascending)
            filtered.sort((a, b) => {
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                if (dateA.getTime() !== dateB.getTime()) {
                    return dateA.getTime() - dateB.getTime(); // Ascending date
                }
                const insNumComparison = String(a.insNumber || '').localeCompare(String(b.insNumber || ''));
                if (insNumComparison !== 0) {
                    return insNumComparison; // Secondary sort by INS Number
                }
                return compareRevisions(a.revision, b.revision); // Tertiary sort by Revision
            });

            filtered.forEach(doc => tableBody.appendChild(renderInspectionRow(doc, 'inspections')));
        }

        function clearInspectionsSearch() {
            document.getElementById('inspectionsSearchField').value = '';
            document.getElementById('inspectionsSearchTerm').value = '';
            performInspectionsSearch();
        }

        function performMirSearch() {
            const tableBody = document.querySelector('#mirTable tbody');
            tableBody.innerHTML = '';
            const field = document.getElementById('mirSearchField').value;
            const term = document.getElementById('mirSearchTerm').value.toLowerCase();
            let filtered = mirData.filter(doc => {
                if (!term) return true;
                // Check against lifecycle status if the field is 'mirRevStatus'
                if (field === 'mirRevStatus' && doc.mirRevStatus) {
                    return String(doc.mirRevStatus).toLowerCase().includes(term);
                } else if (field && doc[field]) {
                    // Apply date formatting for comparison if it's a date field
                    if (field.toLowerCase().includes('date')) {
                        return formatDateForDisplay(doc[field]).toLowerCase().includes(term);
                    }
                    return String(doc[field]).toLowerCase().includes(term);
                }
                // Fallback for general search across all string values, format dates for comparison
                return Object.values(doc).some(value => {
                    if (typeof value === 'string' && value.toLowerCase().includes('date')) { // Heuristic for date fields
                        return formatDateForDisplay(value || '').toLowerCase().includes(term);
                    }
                    return String(value || '').toLowerCase().includes(term);
                });
            });

            // Sort by mirDate (ascending) then MIR Number (ascending) then Revision (ascending)
            filtered.sort((a, b) => {
                const dateA = new Date(a.mirDate);
                const dateB = new Date(b.mirDate);
                if (dateA.getTime() !== dateB.getTime()) {
                    return dateA.getTime() - dateB.getTime(); // Ascending date
                }
                const mirNumComparison = String(a.mirNumber || '').localeCompare(String(b.mirNumber || ''));
                if (mirNumComparison !== 0) {
                    return mirNumComparison; // Secondary sort by MIR Number
                }
                return compareRevisions(a.mirRevision, b.mirRevision); // Tertiary sort by Revision
            });

            filtered.forEach(doc => tableBody.appendChild(renderMirRow(doc, 'mir')));
        }

        function clearMirSearch() {
            document.getElementById('mirSearchField').value = '';
            document.getElementById('mirSearchTerm').value = '';
            performMirSearch();
        }

        function performNcrSearch() {
            const tableBody = document.querySelector('#ncrTable tbody');
            tableBody.innerHTML = '';
            const field = document.getElementById('ncrSearchField').value;
            const term = document.getElementById('ncrSearchTerm').value.toLowerCase();

            // 1. Group NCRs by ncrRefNumber and ncrDiscipline
            const groupedNCRS = {};
            ncrData.forEach(doc => {
                const refNumber = doc.ncrRefNumber;
                const discipline = doc.ncrDiscipline;
                const groupKey = `${refNumber}-${discipline}`;
                if (!groupedNCRS[groupKey]) {
                    groupedNCRS[groupKey] = [];
                }
                    groupedNCRS[groupKey].push(doc);
            });

            // 2. Determine 'Latest' and 'Superseded' status for each group based on Part B Rev
            const ncrDataWithLifecycleStatus = [];
            for (const groupKey in groupedNCRS) {
                const group = groupedNCRS[groupKey];
                if (group.length === 0) continue;

                // Sort the group by ncrRev_PartB to find the latest
                group.sort((a, b) => compareRevisions(a.ncrRev_PartB, b.ncrRev_PartB));
                const latestDoc = group[group.length - 1];

                group.forEach(doc => {
                    const newDoc = { ...doc }; // Create a copy to add new properties
                    if (newDoc.id === latestDoc.id) {
                        newDoc.ncrLifecycleStatus = 'Latest';
                    } else {
                        newDoc.ncrLifecycleStatus = 'Superseded';
                    }
                    ncrDataWithLifecycleStatus.push(newDoc);
                });
            }

            // 3. Apply search and filter on the data with lifecycle status
            let filtered = ncrDataWithLifecycleStatus.filter(doc => {
                if (!term) return true;
                if (field === 'ncrLifecycleStatus' && doc.ncrLifecycleStatus) {
                    return String(doc.ncrLifecycleStatus).toLowerCase().includes(term);
                } else if (field && doc[field]) {
                    // Apply date formatting for comparison if it's a date field
                    if (field.toLowerCase().includes('date')) {
                        return formatDateForDisplay(doc[field]).toLowerCase().includes(term);
                    }
                    return String(doc[field]).toLowerCase().includes(term);
                }
                // Fallback for general search across all string values, format dates for comparison
                return Object.values(doc).some(value => {
                    if (typeof value === 'string' && value.toLowerCase().includes('date')) { // Heuristic for date fields
                        return formatDateForDisplay(value || '').toLowerCase().includes(term);
                    }
                    return String(value || '').toLowerCase().includes(term);
                });
            });

            // 4. Sort the filtered data: Primary by Part A Received Date, Secondary by NCR Ref Number, Tertiary by Part B Revision
            filtered.sort((a, b) => {
                const dateA = new Date(a.partAReceivedDate);
                const dateB = new Date(b.partAReceivedDate);

                if (dateA.getTime() !== dateB.getTime()) {
                    return dateA.getTime() - dateB.getTime(); // Ascending Part A Date
                }

                const refComparison = String(a.ncrRefNumber || '').localeCompare(String(b.ncrRefNumber || ''));
                if (refComparison !== 0) {
                    return refComparison; // Ascending NCR Ref Number
                }

                return compareRevisions(a.ncrRev_PartB, b.ncrRev_PartB); // Ascending Part B Revision
            });

            // 5. Render the filtered and sorted data
            filtered.forEach(doc => tableBody.appendChild(renderNcrRow(doc, 'ncr')));
        }

        function clearNcrSearch() {
            document.getElementById('ncrSearchField').value = '';
            document.getElementById('ncrSearchTerm').value = '';
            performNcrSearch();
        }

        let currentSubmissionFilterStatus = '';
        function searchSubmissionDocuments() {
            const tableBody = document.getElementById('submissionDocumentTable').querySelector('tbody');
            tableBody.innerHTML = '';
            const searchTerm = document.getElementById('submissionSearchInput').value.toLowerCase();
            let filtered = submissionData;

            if (currentSubmissionFilterStatus) {
                filtered = filtered.filter(doc => doc.status === currentSubmissionFilterStatus);
            }

            if (searchTerm) {
                filtered = filtered.filter(doc => {
                    return Object.values(doc).some(value => {
                        if (typeof value === 'string' && value.toLowerCase().includes('date')) { // Heuristic for date fields
                            return formatDateForDisplay(value || '').toLowerCase().includes(searchTerm);
                        }
                        return String(value || '').toLowerCase().includes(searchTerm);
                    });
                });
            }

            // Sort by submittedDate (ascending) then Doc Number (ascending)
            filtered.sort((a, b) => {
                const dateA = new Date(a.submittedDate);
                const dateB = new Date(b.submittedDate);
                if (dateA.getTime() !== dateB.getTime()) {
                    return dateA.getTime() - dateB.getTime(); // Ascending date
                }
                return String(a.docNumber || '').localeCompare(String(b.docNumber || '')); // Secondary sort by Doc Number
            });

            filtered.forEach(doc => tableBody.appendChild(renderSubmissionRow(doc, 'submissions')));
        }

        function clearSubmissionSearch() {
            document.getElementById('submissionSearchInput').value = '';
            currentSubmissionFilterStatus = '';
            searchSubmissionDocuments();
        }

        function filterSubmissionByStatus(status) {
            currentSubmissionFilterStatus = status;
            searchSubmissionDocuments();
        }


        let currentOutgoingFilterStatus = '';
        let currentOutgoingKeywordFilter = '';

        function searchOutgoingCorrespondences() {
            const tableBody = document.querySelector('#outgoingCorrespondenceTable tbody');
            tableBody.innerHTML = '';
            const searchTerm = document.getElementById('outgoingSearchInput').value.toLowerCase();
            let filtered = outgoingCorrespondenceData;

            if (currentOutgoingFilterStatus) {
                filtered = filtered.filter(doc => doc.status === currentOutgoingFilterStatus);
            }
            if (currentOutgoingKeywordFilter) {
                filtered = filtered.filter(doc => doc.keyword === currentOutgoingKeywordFilter);
            }
            if (searchTerm) {
                filtered = filtered.filter(doc => {
                    return Object.values(doc).some(value => {
                        if (typeof value === 'string' && value.toLowerCase().includes('date')) { // Heuristic for date fields
                            return formatDateForDisplay(value || '').toLowerCase().includes(searchTerm);
                        }
                        return String(value || '').toLowerCase().includes(searchTerm);
                    });
                });
            }

            // Sort by letterDate (ascending) then Letter Ref (ascending)
            filtered.sort((a, b) => {
                const dateA = new Date(a.letterDate);
                const dateB = new Date(b.letterDate);
                if (dateA.getTime() !== dateB.getTime()) {
                    return dateA.getTime() - dateB.getTime(); // Ascending date
                }
                return String(a.letterRef || '').localeCompare(String(b.letterRef || '')); // Secondary sort by Letter Ref
            });

            filtered.forEach(doc => tableBody.appendChild(renderOutgoingCorrespondenceRow(doc, 'outgoing_correspondences')));
        }

        function clearOutgoingSearch() {
            document.getElementById('outgoingSearchInput').value = '';
            document.getElementById('outgoingKeywordFilter').value = '';
            currentOutgoingFilterStatus = '';
            currentOutgoingKeywordFilter = '';
            searchOutgoingCorrespondences();
        }

        function filterOutgoingByStatus(status) {
            currentOutgoingFilterStatus = status;
            searchOutgoingCorrespondences();
        }

        function filterOutgoingByKeyword(keyword) {
            currentOutgoingKeywordFilter = keyword;
            searchOutgoingCorrespondences();
        }


        let currentIncomingFilterStatus = '';
        let currentIncomingKeywordFilter = '';

        function searchIncomingCorrespondences() {
            const tableBody = document.querySelector('#incomingCorrespondenceTable tbody');
            tableBody.innerHTML = '';
            const searchTerm = document.getElementById('incomingSearchInput').value.toLowerCase();
            let filtered = incomingCorrespondenceData;

            if (currentIncomingFilterStatus) {
                filtered = filtered.filter(doc => doc.status === currentIncomingFilterStatus);
            }
            if (currentIncomingKeywordFilter) {
                filtered = filtered.filter(doc => doc.keyword === currentIncomingKeywordFilter);
            }
            if (searchTerm) {
                filtered = filtered.filter(doc => {
                    return Object.values(doc).some(value => {
                        if (typeof value === 'string' && value.toLowerCase().includes('date')) { // Heuristic for date fields
                            return formatDateForDisplay(value || '').toLowerCase().includes(searchTerm);
                        }
                        return String(value || '').toLowerCase().includes(searchTerm);
                    });
                });
            }

            // Sort by dateOfReceipt (ascending) then Incoming Ref (ascending)
            filtered.sort((a, b) => {
                const dateA = new Date(a.dateOfReceipt);
                const dateB = new Date(b.dateOfReceipt);
                if (dateA.getTime() !== dateB.getTime()) {
                    return dateA.getTime() - dateB.getTime(); // Ascending date
                }
                return String(a.incomingRef || '').localeCompare(String(b.incomingRef || '')); // Secondary sort by Incoming Ref
            });

            filtered.forEach(doc => tableBody.appendChild(renderIncomingCorrespondenceRow(doc, 'incoming_correspondences')));
        }

        function clearIncomingSearch() {
            document.getElementById('incomingSearchInput').value = '';
            document.getElementById('incomingKeywordFilter').value = '';
            currentIncomingFilterStatus = '';
            currentIncomingKeywordFilter = '';
            searchIncomingCorrespondences();
        }

        function filterIncomingByStatus(status) {
            currentIncomingFilterStatus = status;
            searchIncomingCorrespondences();
        }

        function filterIncomingByKeyword(keyword) {
            currentIncomingKeywordFilter = keyword;
            searchIncomingCorrespondences();
        }


        // --- CSV Download Functions ---

        /**
         * Generic function to download data as a CSV file.
         * @param {Array<Object>} data - Array of objects to be exported.
         * @param {string} filename - The name of the CSV file.
         * @param {Array<string>} headers - An array of strings defining the header order and names.
         * These strings should match the keys in your data objects.
         */
        function downloadCSV(data, filename, headers) {
            if (!data || data.length === 0) {
                showMessageModal("No data to download. Please add some records first.", "No Data");
                return;
            }

            // Create header row based on the provided headers array, ensuring all are quoted
            let csv = headers.map(header => `"${header}"`).join(',') + '\n';

            data.forEach(row => {
                const values = headers.map(header => {
                    let value = row[header];

                    // Special handling for date fields to ensure MM/DD/YYYY format in CSV
                    // The includes('Date') check works for 'date', 'submittedDate', etc.
                    if (header.toLowerCase().includes('date') && typeof value === 'string') {
                        value = formatDateForDisplay(value);
                    }

                    // Handle null/undefined values by converting to empty string
                    // Convert all values to string to ensure .replace() works
                    let stringValue = String(value || '');

                    // Escape double quotes within the string value by replacing them with two double quotes
                    stringValue = stringValue.replace(/"/g, '""');

                    // Enclose the entire value in double quotes
                    return `"${stringValue}"`;
                });
                csv += values.join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Correspondence CSV Headers (Standardized)
        // These headers should be consistently used for both incoming and outgoing for easier Power Query combining
        const CORRESPONDENCE_CSV_HEADERS = [
            'Type', 'Reference', 'Date', 'From', 'To', 'Subject',
            'Reply_Reference', 'Keyword', 'Reply_Required', 'Date_Sent', 'Status'
        ];

        function downloadInspectionsCSV() {
            downloadCSV(inspectionsData, 'inspections_register.csv', [
                'date', 'discipline', 'insNumber', 'revision', 'location',
                'workToBeInspected', 'inspectionDate', 'inspectionTime', // Removed 'submissionType'
                'approvedDrawingRef', 'specificationRef', 'approvedMethodStatementRef',
                'qcsReference', 'commentReceivedDate', 'documentStatus', 'revStatus',
                'approvalSummaryStatus'
            ]);
        }

        function downloadMirCSV() {
            downloadCSV(mirData, 'mir_register.csv', [
                'mirDate', 'mirDiscipline', 'mirNumber', 'mirRevision', 'dateMaterialReceived',
                'mirInspectionDate', 'mirInspectionTime', 'materialApprovalRef', 'descriptionMaterial',
                'deliveryNoteNumber', 'manufacturer', 'supplier', 'countryOrigin',
                'mirSubmissionDate', 'mirResponseDate', 'mirApprovalStatus', 'mirRevStatus',
                'mirApprovalSummaryStatus'
            ]);
        }

        function downloadNcrCSV() {
            // Need to apply lifecycle status before downloading if desired in CSV
            const groupedNCRS = {};
            ncrData.forEach(doc => {
                const refNumber = doc.ncrRefNumber;
                const groupKey = `${refNumber}-${doc.ncrDiscipline}`; // Include discipline in grouping
                if (!groupedNCRS[groupKey]) {
                    groupedNCRS[groupKey] = [];
                }
                groupedNCRS[groupKey].push(doc);
            });
            const ncrDataWithLifecycleStatus = [];
            for (const groupKey in groupedNCRS) {
                const group = groupedNCRS[groupKey];
                if (group.length === 0) continue;
                // Sort by Part B revision for lifecycle status calculation
                group.sort((a, b) => compareRevisions(a.ncrRev_PartB, b.ncrRev_PartB));
                const latestDoc = group[group.length - 1];
                group.forEach(doc => {
                    const newDoc = { ...doc };
                    newDoc.ncrLifecycleStatus = (newDoc.id === latestDoc.id) ? 'Latest' : 'Superseded';
                    ncrDataWithLifecycleStatus.push(newDoc);
                });
            }
            downloadCSV(ncrDataWithLifecycleStatus, 'ncr_register.csv', [
                'ncrRefNumber', 'ncrDiscipline', 'ncrLifecycleStatus', 'ncrDescription',
                'partAReceivedDate', 'ncrRev_PartB', 'ncrRevisedParts_PartB', 'immediateAction',
                'rootCause', 'correctiveAction', 'partBSubmittedDate', 'partCReceivedDate',
                'partBAcceptedByGEC', 'ifPartBAccepted', 'partDRev', 'partDRevisedParts',
                'partDSubmittedDate', 'partEReceivedDate', 'partEStatus', 'ncrCurrentStatus'
            ]);
        }

        function downloadSubmissionCSV() {
            downloadCSV(submissionData, 'submission_register.csv', [
                'docNumber', 'rev', 'discipline', 'docType', 'section', 'docTitle',
                'subRef', 'submittedDate', 'gecDueDate', 'respondedDate', 'status',
                'verifyRev', // This now holds 'Latest' or 'Superseded'
                'daysOverdue'
            ]);
        }

        /**
         * Prepares outgoing correspondence data for CSV export with standardized headers.
         * @returns {Array<Object>} Transformed data.
         */
        function prepareOutgoingForCSV() {
            return outgoingCorrespondenceData.map(doc => ({
                Type: 'Outgoing', // New field for Type
                Reference: doc.letterRef || '',
                Date: doc.letterDate || '',
                From: doc.initiator || '',
                To: doc.addressee || '',
                Subject: doc.letterSubject || '',
                Reply_Reference: doc.inReplyToRef || '',
                Keyword: doc.keyword || '',
                Reply_Required: doc.replyRequired || '',
                Date_Sent: doc.dateSent || '',
                Status: doc.status || ''
            }));
        }

        /**
         * Prepares incoming correspondence data for CSV export with standardized headers.
         * @returns {Array<Object>} Transformed data.
         */
        function prepareIncomingForCSV() {
            return incomingCorrespondenceData.map(doc => ({
                Type: 'Incoming', // New field for Type
                Reference: doc.incomingRef || '',
                Date: doc.dateOfReceipt || '',
                From: doc.originator || '',
                To: doc.addressee || '',
                Subject: doc.letterSubject || '',
                Reply_Reference: doc.replyToRef || '',
                Keyword: doc.keyword || '',
                Reply_Required: doc.replyRequired || '',
                Date_Sent: '', // Incoming correspondences don't have a 'Date Sent'
                Status: doc.status || ''
            }));
        }

        function downloadOutgoingCSV() { // Renamed from downloadOutgoingExcel for clarity
            const dataToExport = prepareOutgoingForCSV();
            downloadCSV(dataToExport, 'outgoing_correspondence_register.csv', CORRESPONDENCE_CSV_HEADERS);
        }

        function downloadIncomingCSV() { // Renamed from downloadIncomingExcel for clarity
            const dataToExport = prepareIncomingForCSV();
            downloadCSV(dataToExport, 'incoming_correspondence_register.csv', CORRESPONDENCE_CSV_HEADERS);
        }

        // --- Pivot Table (Submission Register) ---

        function showPivotTableOptions() {
            document.getElementById('submissionTableContainer').classList.add('hidden');
            document.getElementById('pivotTableContainer').classList.remove('hidden');
            generatePivotTable();
        }

        function hidePivotTable() {
            document.getElementById('pivotTableContainer').classList.add('hidden');
            document.getElementById('submissionTableContainer').classList.remove('hidden');
        }

        function generatePivotTable() {
            const groupByField = document.getElementById('pivotGroupingSelect').value;
            const pivotTable = document.getElementById('pivotTable');
            pivotTable.innerHTML = '<thead></thead><tbody></tbody>';

            const groupedData = {};
            // Using the full text for statuses in the pivot table for clarity
            const statusMap = {
                'UR': 'Under Review',
                'C': 'Revised & Resubmit',
                'A': 'Approved',
                'B': 'Appr. w/ Comments',
                'D': 'Returned',
                'E': 'For Information',
                'X': 'Cancelled'
            };
            const statusesOrder = ['UR', 'C', 'A', 'B', 'D', 'E', 'X']; // Order of columns

            submissionData.forEach(doc => {
                const groupKey = doc[groupByField] || 'N/A';
                if (!groupedData[groupKey]) {
                    groupedData[groupKey] = {};
                    statusesOrder.forEach(status => groupedData[groupKey][status] = 0);
                    groupedData[groupKey].total = 0;
                }
                if (doc.status && statusesOrder.includes(doc.status)) {
                    groupedData[groupKey][doc.status]++;
                }
                groupedData[groupKey].total++;
            });

            const thead = pivotTable.querySelector('thead');
            let headerRow = `<tr><th>${groupByField.charAt(0).toUpperCase() + groupByField.slice(1)}</th>`;
            statusesOrder.forEach(status => {
                headerRow += `<th>${statusMap[status] || status}</th>`; // Use mapped name, fallback to code
            });
            headerRow += `<th>Total</th></tr>`;
            thead.innerHTML = headerRow;

            const tbody = pivotTable.querySelector('tbody');
            for (const groupKey in groupedData) {
                let row = `<tr><td>${groupKey}</td>`;
                statusesOrder.forEach(status => {
                    row += `<td>${groupedData[groupKey][status]}</td>`;
                });
                row += `<td>${groupedData[groupKey].total}</td></tr>`;
                tbody.innerHTML += row;
            }
        }

        function downloadPivotTableCSV() {
            const groupByField = document.getElementById('pivotGroupingSelect').value;
            const statusMap = {
                'UR': 'Under Review',
                'C': 'Revised & Resubmit',
                'A': 'Approved',
                'B': 'Appr. w/ Comments',
                'D': 'Returned',
                'E': 'For Information',
                'X': 'Cancelled'
            };
            const statusesOrder = ['UR', 'C', 'A', 'B', 'D', 'E', 'X'];

            const groupedData = {};
            submissionData.forEach(doc => {
                const groupKey = doc[groupByField] || 'N/A';
                if (!groupedData[groupKey]) {
                    groupedData[groupKey] = {};
                    statusesOrder.forEach(status => groupedData[groupKey][status] = 0);
                    groupedData[groupKey].total = 0;
                }
                if (doc.status && statusesOrder.includes(doc.status)) {
                    groupedData[groupKey][doc.status]++;
                }
                groupedData[groupKey].total++;
            });

            // Create header row using mapped status names
            let csvContent = `"${groupByField}",${statusesOrder.map(status => `"${statusMap[status] || status}"`).join(',')},"Total"\n`;

            for (const groupKey in groupedData) {
                const rowData = statusesOrder.map(status => groupedData[groupKey][status]);
                csvContent += `"${String(groupKey || '').replace(/"/g, '""')}",${rowData.join(',')},${groupedData[groupKey].total}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.setAttribute('download', 'submission_pivot_table.csv');
            document.body.appendChild(link);
            document.body.removeChild(link);
        }


        // --- Event Listeners and Initial Load ---

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded fired. Initializing UI elements and then Firebase.");

            // Initial setup of fixed dropdowns and showing the default page
            populateFixedDropdowns();
            showPage('inspectionsPage'); // Still default to this page when app is visible
            showCorrespondenceSection('outgoingCorrespondenceSection'); // Default to outgoing correspondence

            // Attach event listeners to input fields for calculated values
            // Inspections Register
            document.getElementById('discipline').addEventListener('change', updateNextInsNumber);
            // documentStatus now selects, no direct revStatus calculation based on it for the 'revStatus' field
            // The `approvalSummaryStatus` will be calculated during add/update

            // MIR Register
            document.getElementById('mirDiscipline').addEventListener('change', updateNextMirNumber);
            // mirApprovalStatus now selects, no direct mirRevStatus calculation based on it for the 'mirRevStatus' field
            // The `mirApprovalSummaryStatus` will be calculated during add/update

            // NCR Register (unchanged as it already has the lifecycle status logic)
            document.getElementById('partBAcceptedByGEC').addEventListener('change', (e) => {
                if (e.target.value === 'Yes') {
                    document.getElementById('ifPartBAccepted').value = 'Submit Part D';
                    document.getElementById('partDRev').value = document.getElementById('ncrRev_PartB').value;
                    document.getElementById('partDRevisedParts').value = 'Part D only';
                } else if (e.target.value === 'No') {
                    document.getElementById('ifPartBAccepted').value = 'Resubmit Part B';
                    document.getElementById('partDRev').value = '';
                    document.getElementById('partDRevisedParts').value = '';
                } else {
                    document.getElementById('ifPartBAccepted').value = '';
                    document.getElementById('partDRev').value = '';
                    document.getElementById('partDRevisedParts').value = '';
                }
            });

            // Submission Register - Recalculate days overdue on date change (verifyRev is now automatic)
            document.getElementById('newSubmittedDate').addEventListener('change', () => {
                const submittedDate = document.getElementById('newSubmittedDate').value;
                const respondedDate = document.getElementById('newRespondedDate').value;
                // Re-calculate GEC Due Date based on submittedDate
                if (submittedDate) {
                    const subDateObj = new Date(submittedDate);
                    const dueDateObj = new Date(subDateObj); // Create a new Date object for dueDate
                    dueDateObj.setDate(subDateObj.getDate() + 14); // Add 14 days
                    document.getElementById('gecDueDate').value = dueDateObj.toISOString().split('T')[0];
                } else {
                    document.getElementById('gecDueDate').value = '';
                }
                document.getElementById('daysOverdue').value = calculateDaysOverdue(submittedDate, respondedDate);
            });
            document.getElementById('newRespondedDate').addEventListener('change', () => {
                const submittedDate = document.getElementById('newSubmittedDate').value;
                const respondedDate = document.getElementById('newRespondedDate').value;
                document.getElementById('daysOverdue').value = calculateDaysOverdue(submittedDate, respondedDate);
            });
            // The newStatus (approval status) change no longer affects verifyRev directly in the form
            // as verifyRev is now purely 'Latest'/'Superseded' based on revision logic.
            // The daysOverdue calculation remains, but no more `calculateRevStatus`
            document.getElementById('newStatus').addEventListener('change', () => {
                const submittedDate = document.getElementById('newSubmittedDate').value;
                const respondedDate = document.getElementById('newRespondedDate').value;
                document.getElementById('daysOverdue').value = calculateDaysOverdue(submittedDate, respondedDate);
            });


            // Start Firebase initialization as an asynchronous process
            initializeFirebaseAndAuth();
        });

        // Function to load all data listeners after authentication is ready
        async function loadAllDataListeners() {
            console.log("Loading all data listeners...");
            setupRealtimeListener('inspections');
            setupRealtimeListener('mir');
            setupRealtimeListener('ncr');
            setupRealtimeListener('submissions');
            setupRealtimeListener('outgoing_correspondences');
            setupRealtimeListener('incoming_correspondences');

            // Initial updates for numbers that depend on loaded data
            updateNextInsNumber();
            updateNextMirNumber();
        }

        // --- Expose functions to the global scope for HTML onclick attributes ---
        // These are critical for the HTML `onclick` attributes to find the functions.
        window.showPage = showPage;
        window.handleCustomConfirm = handleCustomConfirm;
        window.showMessageModal = showMessageModal;
        window.hideMessageModal = hideMessageModal;
        window.showLoadingOverlay = showLoadingOverlay;
        window.hideLoadingOverlay = hideLoadingOverlay;
        window.showCustomConfirm = showCustomConfirm; // Expose the Promise-based custom confirm

        // Auth
        window.toggleAuthMode = toggleAuthMode;
        window.handleAuthSubmit = handleAuthSubmit;
        window.handleSignOut = handleSignOut;
        window.signInAnonymouslyUser = signInAnonymouslyUser;
        window.showForgotPasswordModal = showForgotPasswordModal; // Expose new function
        window.hideForgotPasswordModal = hideForgotPasswordModal; // Expose new function
        window.sendPasswordReset = sendPasswordReset; // Expose new function

        // Inspections
        window.addUpdateInspectionDocument = addUpdateInspectionDocument;
        window.clearInspectionsForm = clearInspectionsForm;
        window.editInspection = editInspection;
        window.performInspectionsSearch = performInspectionsSearch;
        window.clearInspectionsSearch = clearInspectionsSearch;
        window.downloadInspectionsCSV = downloadInspectionsCSV;
        // MIR
        window.addUpdateMirDocument = addUpdateMirDocument;
        window.clearMirForm = clearMirForm;
        window.editMir = editMir;
        window.performMirSearch = performMirSearch;
        window.clearMirSearch = clearMirSearch;
        window.downloadMirCSV = downloadMirCSV;
        // NCR
        window.handleNcrFormSubmission = handleNcrFormSubmission; // Renamed from addUpdateNcrDocument
        window.clearNcrForm = clearNcrForm;
        window.editNcr = editNcr;
        window.performNcrSearch = performNcrSearch;
        window.autoFillNcrDetails = autoFillNcrDetails; // Expose
        window.clearNcrSearch = clearNcrSearch;
        window.downloadNcrCSV = downloadNcrCSV;
        // Submissions
        window.addNewSubmissionDocument = addNewSubmissionDocument;
        window.clearNewSubmissionDocumentForm = clearNewSubmissionDocumentForm;
        window.editSubmission = editSubmission;
        window.searchSubmissionDocuments = searchSubmissionDocuments;
        window.clearSubmissionSearch = clearSubmissionSearch;
        window.filterSubmissionByStatus = filterSubmissionByStatus;
        window.downloadSubmissionCSV = downloadSubmissionCSV;
        window.showPivotTableOptions = showPivotTableOptions;
        window.hidePivotTable = hidePivotTable;
        window.generatePivotTable = generatePivotTable;
        window.downloadPivotTableCSV = downloadPivotTableCSV;
        // Correspondence
        window.showCorrespondenceSection = showCorrespondenceSection;
        // Outgoing Correspondence
        window.addNewOutgoingCorrespondence = addNewOutgoingCorrespondence;
        window.clearNewOutgoingCorrespondenceForm = clearNewOutgoingCorrespondenceForm;
        window.editOutgoing = editOutgoing;
        window.searchOutgoingCorrespondences = searchOutgoingCorrespondences;
        window.clearOutgoingSearch = clearOutgoingSearch;
        window.filterOutgoingByStatus = filterOutgoingByStatus;
        window.filterOutgoingByKeyword = filterOutgoingByKeyword;
        window.downloadOutgoingCSV = downloadOutgoingCSV; // Updated name
        // Incoming Correspondence
        window.addNewIncomingCorrespondence = addNewIncomingCorrespondence;
        window.clearNewIncomingCorrespondenceForm = clearNewIncomingCorrespondenceForm;
        window.editIncoming = editIncoming;
        window.searchIncomingCorrespondences = searchIncomingCorrespondences;
        window.clearIncomingSearch = clearIncomingSearch;
        window.filterIncomingByStatus = filterIncomingByStatus;
        window.filterIncomingByKeyword = filterIncomingByKeyword;
        window.downloadIncomingCSV = downloadIncomingCSV; // Updated name
        // General UI
        window.toggleTableVisibility = toggleTableVisibility;

        // CRITICAL: Expose the deleteDocument function to the global scope
        window.deleteDocument = deleteDocument;
    </script>
</body>
</html>
